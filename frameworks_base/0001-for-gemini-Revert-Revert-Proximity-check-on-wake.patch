From e76783eccc5148a5e7f94de989f4418ae4e12373 Mon Sep 17 00:00:00 2001
From: Kazakov Stepan <ksrt12group@gmail.com>
Date: Mon, 13 May 2019 01:48:51 +0300
Subject: [PATCH 01/12] for gemini: Revert "Revert "Proximity check on wake""

Revert "pocket: Use MD2 lock drawable"

This reverts commit 51c0360146737491405420802614ba1207eeaa9c.

Revert "base: Make FP detection in pocket mode configurable [1/2]"

This reverts commit 715da0ca193f26b33ef5fe0f88ed8da98a8e5944.

Revert "pocket: Allow to listen for fingerprint"

This reverts commit 910f16a6dc03de36c740ee34263245d238556e04.

Revert "Pocket lock improvements"

This reverts commit 61e41cfe3e8c7a12f376b8b5b705124f7dd24166.

Revert "pocket: Don't show immersive mode confirmation when UI showing"

This reverts commit e7a5e359d992c3a4aee12cce9a82e9c40f133a77.

Revert "pocket: Fix pocket lock view for display cutouts"

This reverts commit aacd27da73811d028e3ae4c8afcac9265c54117b.

Revert "pocket: Adjust sleep timeout for pocket lock view to 10 secs"

This reverts commit 75571eaabd4d3221912259b8f145f10083badaac.

Revert "pocket: introduce pocket bridge"

This reverts commit 235de4c4a3eb483615e5805578dee6a02050387e.

Revert "PocketService: Adjust light sensor rate to 400ms"

This reverts commit 368fb959bb1a18b5dd6fcbfcca57e3f41eb6616a.

Revert "pocket: Add hardware acceleration and properly maintain SYSTEM_UI flags"

This reverts commit b6ac06ba151182a29c5714603c363700457d6701.

Revert "policy: introduce pocket lock"

This reverts commit bbc95934c038c111d032e2d8d5a662ff59ca24d2.

Revert "pocket: introduce pocket judge"

This reverts commit af68b044876976b8ccfdb57d81d7c0002a38ba3b.

Revert "Revert "Proximity check on wake""

This reverts commit 6e89a6738b49c540f205eda5467f715687fbcc1d.

Signed-off-by: Kazakov Stepan <ksrt12group@gmail.com>
---
 Android.bp                                    |   2 -
 CleanSpec.mk                                  |   1 -
 .../android/app/SystemServiceRegistry.java    |  11 -
 core/java/android/content/Context.java        |  10 -
 core/java/android/os/IPowerManager.aidl       |   2 +
 core/java/android/os/PowerManager.java        |  16 +
 core/java/android/pocket/IPocketCallback.aidl |  24 -
 core/java/android/pocket/IPocketService.aidl  |  43 -
 core/java/android/pocket/PocketConstants.java |  25 -
 core/java/android/pocket/PocketManager.java   | 233 ------
 core/java/android/provider/Settings.java      |  33 +-
 core/res/res/drawable/ic_pocket_lock.xml      |  10 -
 .../res/layout/pocket_lock_view_layout.xml    |  42 -
 core/res/res/values/havoc_config.xml          |  11 +-
 core/res/res/values/havoc_strings.xml         |   3 -
 core/res/res/values/havoc_symbols.xml         |  18 +-
 .../android/keyguard/KeyguardHostView.java    |   5 +-
 .../keyguard/KeyguardUpdateMonitor.java       |  56 +-
 .../systemui/statusbar/phone/StatusBar.java   |  14 -
 .../server/pocket/PocketBridgeService.java    | 177 -----
 .../android/server/pocket/PocketService.java  | 751 ------------------
 .../policy/ImmersiveModeConfirmation.java     |   8 +-
 .../server/policy/PhoneWindowManager.java     | 216 +----
 .../server/policy/pocket/PocketLock.java      | 190 -----
 .../server/power/PowerManagerService.java     | 147 +++-
 .../java/com/android/server/SystemServer.java |  12 -
 26 files changed, 236 insertions(+), 1824 deletions(-)
 delete mode 100644 core/java/android/pocket/IPocketCallback.aidl
 delete mode 100644 core/java/android/pocket/IPocketService.aidl
 delete mode 100644 core/java/android/pocket/PocketConstants.java
 delete mode 100644 core/java/android/pocket/PocketManager.java
 delete mode 100644 core/res/res/drawable/ic_pocket_lock.xml
 delete mode 100644 core/res/res/layout/pocket_lock_view_layout.xml
 delete mode 100644 services/core/java/com/android/server/pocket/PocketBridgeService.java
 delete mode 100644 services/core/java/com/android/server/pocket/PocketService.java
 delete mode 100644 services/core/java/com/android/server/policy/pocket/PocketLock.java

diff --git a/Android.bp b/Android.bp
index 02ab794c15b2..ef64d5e7841a 100644
--- a/Android.bp
+++ b/Android.bp
@@ -249,8 +249,6 @@ java_library {
         "core/java/android/os/storage/IStorageEventListener.aidl",
         "core/java/android/os/storage/IStorageShutdownObserver.aidl",
         "core/java/android/os/storage/IObbActionListener.aidl",
-        "core/java/android/pocket/IPocketService.aidl",
-        "core/java/android/pocket/IPocketCallback.aidl",
         ":keystore_aidl",
         "core/java/android/security/keymaster/IKeyAttestationApplicationIdProvider.aidl",
         "core/java/android/service/autofill/IAutoFillService.aidl",
diff --git a/CleanSpec.mk b/CleanSpec.mk
index f2a75884f4a2..2e949c5c05a9 100644
--- a/CleanSpec.mk
+++ b/CleanSpec.mk
@@ -78,7 +78,6 @@ $(call add-clean-step, rm -rf $(PRODUCT_OUT)/symbols/system/lib/libhwui.so)
 $(call add-clean-step, rm -rf $(PRODUCT_OUT)/system/lib/libhwui.so)
 $(call add-clean-step, rm -rf $(OUT_DIR)/target/common/obj/JAVA_LIBRARIES/framework_intermediates/src/core/java/android/os/storage/*)
 $(call add-clean-step, rm -rf $(OUT_DIR)/target/common/obj/JAVA_LIBRARIES/framework_intermediates/src/core/java/android/content/IClipboard.P)
-$(call add-clean-step, rm -rf $(OUT_DIR)/target/common/obj/JAVA_LIBRARIES/framework_intermediates/src/core/java/android/pocket/*)
 $(call add-clean-step, rm -rf $(OUT_DIR)/target/common/obj/JAVA_LIBRARIES/framework_intermediates/src/telephony/java/com/android/internal/telephony/ITelephonyRegistry.P)
 $(call add-clean-step, rm -rf $(OUT_DIR)/target/common/obj/JAVA_LIBRARIES/android_stubs_current_intermediates)
 $(call add-clean-step, rm -rf $(OUT_DIR)/target/common/docs/api-stubs*)
diff --git a/core/java/android/app/SystemServiceRegistry.java b/core/java/android/app/SystemServiceRegistry.java
index 2697f74a3151..867dff0ee66c 100644
--- a/core/java/android/app/SystemServiceRegistry.java
+++ b/core/java/android/app/SystemServiceRegistry.java
@@ -128,8 +128,6 @@ import android.os.UserManager;
 import android.os.Vibrator;
 import android.os.health.SystemHealthManager;
 import android.os.storage.StorageManager;
-import android.pocket.IPocketService;
-import android.pocket.PocketManager;
 import android.print.IPrintManager;
 import android.print.PrintManager;
 import android.service.oemlock.IOemLockService;
@@ -785,15 +783,6 @@ final class SystemServiceRegistry {
                 return new FingerprintManager(ctx.getOuterContext(), service);
             }});
 
-        registerService(Context.POCKET_SERVICE, PocketManager.class,
-                new CachedServiceFetcher<PocketManager>() {
-                    @Override
-                    public PocketManager createService(ContextImpl ctx) {
-                        IBinder binder = ServiceManager.getService(Context.POCKET_SERVICE);
-                        IPocketService service = IPocketService.Stub.asInterface(binder);
-                        return new PocketManager(ctx.getOuterContext(), service);
-                    }});
-
         registerService(Context.TV_INPUT_SERVICE, TvInputManager.class,
                 new CachedServiceFetcher<TvInputManager>() {
             @Override
diff --git a/core/java/android/content/Context.java b/core/java/android/content/Context.java
index 40d90cf334ce..229141613e8e 100644
--- a/core/java/android/content/Context.java
+++ b/core/java/android/content/Context.java
@@ -4229,16 +4229,6 @@ public abstract class Context {
     @SystemApi
     public static final String SECURE_ELEMENT_SERVICE = "secure_element";
 
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.os.PocketManager} for accessing and listening to device pocket state.
-     *
-     * @hide
-     * @see #getSystemService
-     * @see android.os.PocketManager
-     */
-    public static final String POCKET_SERVICE = "pocket";
-
     /**
      * Determine whether the given permission is allowed for a particular
      * process and user ID running in the system.
diff --git a/core/java/android/os/IPowerManager.aidl b/core/java/android/os/IPowerManager.aidl
index b5c8a2b1b7dd..626abe7d4875 100644
--- a/core/java/android/os/IPowerManager.aidl
+++ b/core/java/android/os/IPowerManager.aidl
@@ -69,6 +69,8 @@ interface IPowerManager
     // controls whether PowerManager should doze after the screen turns off or not
     void setDozeAfterScreenOff(boolean on);
 
+    void wakeUpWithProximityCheck(long time, String reason, String opPackageName);
+
     // update the uids being synchronized by network socket request manager
     void updateBlockedUids(int uid, boolean isBlocked);
 
diff --git a/core/java/android/os/PowerManager.java b/core/java/android/os/PowerManager.java
index a61ec20459c3..29e557b27b2b 100644
--- a/core/java/android/os/PowerManager.java
+++ b/core/java/android/os/PowerManager.java
@@ -958,6 +958,22 @@ public final class PowerManager {
         }
     }
 
+    /**
+     * Forces the device to wake up from sleep only if
+     * nothing is blocking the proximity sensor
+     *
+     * @see #wakeUp
+     *
+     * @hide
+     */
+    public void wakeUpWithProximityCheck(long time, String reason) {
+        try {
+            mService.wakeUpWithProximityCheck(time, reason, mContext.getOpPackageName());
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
     /**
      * Forces the device to start napping.
      * <p>
diff --git a/core/java/android/pocket/IPocketCallback.aidl b/core/java/android/pocket/IPocketCallback.aidl
deleted file mode 100644
index 53e5412f89be..000000000000
--- a/core/java/android/pocket/IPocketCallback.aidl
+++ /dev/null
@@ -1,24 +0,0 @@
-/**
- * Copyright (C) 2016 The ParanoidAndroid Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package android.pocket;
-
-/** @hide */
-interface IPocketCallback {
-
-    // notify when pocket state changes.
-    void onStateChanged(boolean isDeviceInPocket, int reason);
-
-}
\ No newline at end of file
diff --git a/core/java/android/pocket/IPocketService.aidl b/core/java/android/pocket/IPocketService.aidl
deleted file mode 100644
index 783465774207..000000000000
--- a/core/java/android/pocket/IPocketService.aidl
+++ /dev/null
@@ -1,43 +0,0 @@
-/**
- * Copyright (C) 2016 The ParanoidAndroid Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package android.pocket;
-
-import android.pocket.IPocketCallback;
-
-/** @hide */
-interface IPocketService {
-
-    // add callback to get notified about pocket state.
-    void addCallback(IPocketCallback callback);
-
-    // remove callback and stop getting notified about pocket state.
-    void removeCallback(IPocketCallback callback);
-
-    // notify pocket service about intercative state changed.
-    // @see com.android.policy.PhoneWindowManager
-    void onInteractiveChanged(boolean interactive);
-
-    // external processes can request changing listening state.
-    void setListeningExternal(boolean listen);
-
-    // check if device is in pocket.
-    boolean isDeviceInPocket();
-
-    // Custom methods
-    void setPocketLockVisible(boolean visible);
-    boolean isPocketLockVisible();
-
-}
\ No newline at end of file
diff --git a/core/java/android/pocket/PocketConstants.java b/core/java/android/pocket/PocketConstants.java
deleted file mode 100644
index f0d08a272375..000000000000
--- a/core/java/android/pocket/PocketConstants.java
+++ /dev/null
@@ -1,25 +0,0 @@
-package android.pocket;
-
-/**
- * This class contains global pocket setup constants.
- * @author Carlo Savignano
- * @hide
- */
-
-public class PocketConstants {
-
-    public static final boolean DEBUG = false;
-    public static final boolean DEBUG_SPEW = false;
-
-    /**
-     * Whether to use proximity sensor to evaluate pocket state.
-     */
-    public static final boolean ENABLE_PROXIMITY_JUDGE = true;
-
-    /**
-     * Whether to use light sensor to evaluate pocket state.
-     */
-    public static final boolean ENABLE_LIGHT_JUDGE = true;
-
-
-}
diff --git a/core/java/android/pocket/PocketManager.java b/core/java/android/pocket/PocketManager.java
deleted file mode 100644
index 925f52a961ab..000000000000
--- a/core/java/android/pocket/PocketManager.java
+++ /dev/null
@@ -1,233 +0,0 @@
-/**
- * Copyright (C) 2016 The ParanoidAndroid Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package android.pocket;
-
-import android.content.Context;
-import android.os.Handler;
-import android.os.PowerManager;
-import android.os.RemoteException;
-import android.os.SystemClock;
-import android.text.format.DateUtils;
-import android.util.Log;
-import android.util.Slog;
-
-/**
- * A class that coordinates listening for pocket state.
- * <p>
- * Use {@link android.content.Context#getSystemService(java.lang.String)}
- * with argument {@link android.content.Context#POCKET_SERVICE} to get
- * an instance of this class.
- *
- * Usage: import and create a final {@link IPocketCallback.Stub()} and implement your logic in
- * {@link IPocketCallback#onStateChanged(boolean, int)}. Then add your callback to the pocket manager
- *
- * // define a final callback
- * private final IPocketCallback mCallback = new IPocketCallback.Stub() {
- *
- *     @Override
- *     public void onStateChanged(boolean isDeviceInPocket, int reason) {
- *         // Your method to handle logic outside of this callback, ideally with a handler
- *         // posting on UI Thread for view hierarchy operations or with its own background thread.
- *         handlePocketStateChanged(isDeviceInPocket, reason);
- *     }
- *
- * }
- *
- * // add callback to pocket manager
- * private void addCallback() {
- *     PocketManager manager = (PocketManager) context.getSystemService(Context.POCKET_SERVICE);
- *     manager.addCallback(mCallback);
- * }
- *
- * @author Carlo Savignano
- * @hide
- */
-public class PocketManager {
-
-    private static final String TAG = PocketManager.class.getSimpleName();
-    static final boolean DEBUG = false;
-
-    /**
-     * Whether {@link IPocketCallback#onStateChanged(boolean, int)}
-     * was fired because of the sensor.
-     * @see PocketService#handleDispatchCallbacks()
-     */
-    public static final int REASON_SENSOR = 0;
-
-    /**
-     * Whether {@link IPocketCallback#onStateChanged(boolean, int)}
-     * was fired because of an error while accessing service.
-     * @see #addCallback(IPocketCallback)
-     * @see #removeCallback(IPocketCallback)
-     */
-    public static final int REASON_ERROR = 1;
-
-    /**
-     * Whether {@link IPocketCallback#onStateChanged(boolean, int)}
-     * was fired because of a needed reset.
-     * @see PocketService#binderDied()
-     */
-    public static final int REASON_RESET = 2;
-
-    private Context mContext;
-    private IPocketService mService;
-    private PowerManager mPowerManager;
-    private Handler mHandler;
-    private boolean mPocketViewTimerActive;
-
-    public PocketManager(Context context, IPocketService service) {
-        mContext = context;
-        mService = service;
-        if (mService == null) {
-            Slog.v(TAG, "PocketService was null");
-        }
-        mPowerManager = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
-        mHandler = new Handler();
-    }
-
-    /**
-     * Add pocket state callback.
-     * @see PocketService#handleRemoveCallback(IPocketCallback)
-     */
-    public void addCallback(final IPocketCallback callback) {
-        if (mService != null) try {
-            mService.addCallback(callback);
-        } catch (RemoteException e1) {
-            Log.w(TAG, "Remote exception in addCallback: ", e1);
-            if (callback != null){
-                try {
-                    callback.onStateChanged(false, REASON_ERROR);
-                } catch (RemoteException e2) {
-                    Log.w(TAG, "Remote exception in callback.onPocketStateChanged: ", e2);
-                }
-            }
-        }
-    }
-
-    /**
-     * Remove pocket state callback.
-     * @see PocketService#handleAddCallback(IPocketCallback)
-     */
-    public void removeCallback(final IPocketCallback callback) {
-        if (mService != null) try {
-            mService.removeCallback(callback);
-        } catch (RemoteException e1) {
-            Log.w(TAG, "Remote exception in removeCallback: ", e1);
-            if (callback != null){
-                try {
-                    callback.onStateChanged(false, REASON_ERROR);
-                } catch (RemoteException e2) {
-                    Log.w(TAG, "Remote exception in callback.onPocketStateChanged: ", e2);
-                }
-            }
-        }
-    }
-
-    /**
-     * Notify service about device interactive state changed.
-     * {@link PhoneWindowManager#startedWakingUp()}
-     * {@link PhoneWindowManager#startedGoingToSleep(int)}
-     */
-    public void onInteractiveChanged(boolean interactive) {
-        boolean isPocketViewShowing = (interactive && isDeviceInPocket());
-        synchronized (mPocketLockTimeout) {
-            if (mPocketViewTimerActive != isPocketViewShowing) {
-                if (isPocketViewShowing) {
-                    if (DEBUG) Log.v(TAG, "Setting pocket timer");
-                    mHandler.removeCallbacks(mPocketLockTimeout); // remove any pending requests
-                    mHandler.postDelayed(mPocketLockTimeout, 10 * DateUtils.SECOND_IN_MILLIS);
-                    mPocketViewTimerActive = true;
-                } else {
-                    if (DEBUG) Log.v(TAG, "Clearing pocket timer");
-                    mHandler.removeCallbacks(mPocketLockTimeout);
-                    mPocketViewTimerActive = false;
-                }
-            }
-        }
-        if (mService != null) try {
-            mService.onInteractiveChanged(interactive);
-        } catch (RemoteException e) {
-            Log.w(TAG, "Remote exception in addCallback: ", e);
-        }
-    }
-
-    /**
-     * Request listening state change by, but not limited to, external process.
-     * @see PocketService#handleSetListeningExternal(boolean)
-     */
-    public void setListeningExternal(boolean listen) {
-        if (mService != null) try {
-            mService.setListeningExternal(listen);
-        } catch (RemoteException e) {
-            Log.w(TAG, "Remote exception in setListeningExternal: ", e);
-        }
-        // Clear timeout when user hides pocket lock with long press power.
-        if (mPocketViewTimerActive && !listen) {
-            if (DEBUG) Log.v(TAG, "Clearing pocket timer due to override");
-            mHandler.removeCallbacks(mPocketLockTimeout);
-            mPocketViewTimerActive = false;
-        }
-    }
-
-    /**
-     * Return whether device is in pocket.
-     * @see PocketService#isDeviceInPocket()
-     * @return
-     */
-    public boolean isDeviceInPocket() {
-        if (mService != null) try {
-            return mService.isDeviceInPocket();
-        } catch (RemoteException e) {
-            Log.w(TAG, "Remote exception in isDeviceInPocket: ", e);
-        }
-        return false;
-    }
-
-    class PocketLockTimeout implements Runnable {
-        @Override
-        public void run() {
-            mPowerManager.goToSleep(SystemClock.uptimeMillis());
-            mPocketViewTimerActive = false;
-        }
-    }
-
-    /** Custom methods **/
-
-    public void setPocketLockVisible(boolean visible) {
-        if (!visible){
-            if (DEBUG) Log.v(TAG, "Clearing pocket timer");
-            mHandler.removeCallbacks(mPocketLockTimeout);
-            mPocketViewTimerActive = false;
-        }
-        if (mService != null) try {
-            mService.setPocketLockVisible(visible);
-        } catch (RemoteException e) {
-            Log.w(TAG, "Remote exception in setPocketLockVisible: ", e);
-        }
-    }
-
-    public boolean isPocketLockVisible() {
-        if (mService != null) try {
-            return mService.isPocketLockVisible();
-        } catch (RemoteException e) {
-            Log.w(TAG, "Remote exception in isPocketLockVisible: ", e);
-        }
-        return false;
-    }
-
-    private PocketLockTimeout mPocketLockTimeout = new PocketLockTimeout();
-
-}
diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index 56ea7634bc7d..76a50d4782a0 100644
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -4063,6 +4063,12 @@ public final class Settings {
 
         private static final Validator DOCK_SOUNDS_ENABLED_VALIDATOR = BOOLEAN_VALIDATOR;
 
+        /**
+         * Check the proximity sensor during wakeup
+         * @hide
+         */
+        public static final String PROXIMITY_ON_WAKE = "proximity_on_wake";
+
         /**
          * Whether to play sounds when the keyguard is shown and dismissed.
          * @hide
@@ -5511,6 +5517,14 @@ public final class Settings {
          */
         public static final String SHOW_FOURG_ICON = "show_fourg_icon";
 
+        /**
+         * Whether allowing pocket service to register sensors and dispatch informations.
+         * 0 = disabled
+         * 1 = enabled
+         * @hide
+         */
+        public static final String POCKET_JUDGE = "pocket_judge";
+
         /**
          * Whether to disable showing arrows in network traffic indicators
          * @hide
@@ -6623,23 +6637,6 @@ public final class Settings {
         public static final Validator LIVE_DISPLAY_HINTED_VALIDATOR =
                 new SettingsValidators.InclusiveIntegerRangeValidator(-3, 1);
 
-        /**
-         * Whether allowing pocket service to register sensors and dispatch informations.
-         *   0 = disabled
-         *   1 = enabled
-         * @author Carlo Savignano
-         * @hide
-         */
-        public static final String POCKET_JUDGE = "pocket_judge";
-
-        /** @hide */
-        public static final Validator POCKET_JUDGE_VALIDATOR = BOOLEAN_VALIDATOR;
-
-        /**
-         * @hide
-         */
-        public static final String POCKET_JUDGE_ALLOW_FP = "pocket_judge_allow_fp";
-
         /**
          * @hide
          */
@@ -7012,7 +7009,6 @@ public final class Settings {
             PRIVATE_SETTINGS.add(DISPLAY_COLOR_ADJUSTMENT);
             PRIVATE_SETTINGS.add(DISPLAY_PICTURE_ADJUSTMENT);
             PRIVATE_SETTINGS.add(LIVE_DISPLAY_HINTED);
-            PRIVATE_SETTINGS.add(POCKET_JUDGE);
         }
 
         /**
@@ -7204,7 +7200,6 @@ public final class Settings {
             VALIDATORS.put(DISPLAY_COLOR_ADJUSTMENT, DISPLAY_COLOR_ADJUSTMENT_VALIDATOR);
             VALIDATORS.put(DISPLAY_PICTURE_ADJUSTMENT, DISPLAY_PICTURE_ADJUSTMENT_VALIDATOR);
             VALIDATORS.put(LIVE_DISPLAY_HINTED, LIVE_DISPLAY_HINTED_VALIDATOR);
-            VALIDATORS.put(POCKET_JUDGE, POCKET_JUDGE_VALIDATOR);
         }
 
         /**
diff --git a/core/res/res/drawable/ic_pocket_lock.xml b/core/res/res/drawable/ic_pocket_lock.xml
deleted file mode 100644
index 3494a8f38b84..000000000000
--- a/core/res/res/drawable/ic_pocket_lock.xml
+++ /dev/null
@@ -1,10 +0,0 @@
-<vector xmlns:android="http://schemas.android.com/apk/res/android"
-        android:width="24dp"
-        android:height="24dp"
-        android:viewportWidth="24.0"
-        android:viewportHeight="24.0"
-        android:tint="?android:attr/colorControlActivated">
-    <path
-        android:fillColor="#ffffffff"
-        android:pathData="M12,17C10.89,17 10,16.1 10,15C10,13.89 10.89,13 12,13A2,2 0 0,1 14,15A2,2 0 0,1 12,17M18,20V10H6V20H18M18,8A2,2 0 0,1 20,10V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V10C4,8.89 4.89,8 6,8H7V6A5,5 0 0,1 12,1A5,5 0 0,1 17,6V8H18M12,3A3,3 0 0,0 9,6V8H15V6A3,3 0 0,0 12,3Z" />
-</vector>
diff --git a/core/res/res/layout/pocket_lock_view_layout.xml b/core/res/res/layout/pocket_lock_view_layout.xml
deleted file mode 100644
index 0e0ea3fd7cfd..000000000000
--- a/core/res/res/layout/pocket_lock_view_layout.xml
+++ /dev/null
@@ -1,42 +0,0 @@
-<LinearLayout
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    android:layout_gravity="center"
-    android:gravity="center"
-    android:background="@android:color/black">
-
-    <LinearLayout
-        android:id="@+id/pocket_hint_container"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"
-        android:layout_gravity="center"
-        android:gravity="center"
-        android:orientation="vertical">
-
-        <ImageView
-            android:id="@+id/pocket_hint_image"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:layout_gravity="center_horizontal"
-            android:gravity="center_horizontal"
-            android:padding="10dp"
-            android:src="@android:drawable/ic_pocket_lock"
-            android:tint="@android:color/white"
-            android:alpha="1.0"/>
-
-        <TextView
-            android:id="@+id/pocket_hint_message"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:layout_gravity="center_horizontal"
-            android:gravity="center_horizontal"
-            android:padding="10dp"
-            android:text="@android:string/pocket_lock_message_long_press"
-            android:textColor="@android:color/white"
-            android:alpha="0.7"/>
-
-    </LinearLayout>
-
-
-</LinearLayout>
diff --git a/core/res/res/values/havoc_config.xml b/core/res/res/values/havoc_config.xml
index c4f030e6d283..1877befd95d0 100644
--- a/core/res/res/values/havoc_config.xml
+++ b/core/res/res/values/havoc_config.xml
@@ -174,6 +174,13 @@
     <!-- Component name for the activity that will be presenting the Oreo's Recents UI -->
     <string name="config_recentsComponentNameOreo" translatable="false">com.android.systemui/.recents.RecentsActivity</string>
 
+    <!-- Default value for proximity check on screen wake
+         NOTE ! - Enable for devices that have a fast response proximity sensor (ideally < 300ms)
+    -->
+    <bool name="config_proximityCheckOnWake">false</bool>
+    <integer name="config_proximityCheckTimeout">250</integer>
+    <bool name="config_proximityCheckOnWakeEnabledByDefault">false</bool>
+
     <!-- Component name of the combo network location provider. -->
     <string name="config_comboNetworkLocationProvider" translatable="false">@null</string>
 
@@ -281,10 +288,6 @@
     <!-- Should we filter any display modes which are unampped? -->
     <bool name="config_filterDisplayModes">false</bool>
 
-    <!-- Defines the sysfs attribute path used by pocket bridge
-        to communicate pocket state to the pocket judge kernel driver. -->
-    <string name="config_pocketBridgeSysfsInpocket"></string>
-
     <!-- Smart charging battery percentage -->
     <integer name="config_smartChargingBatteryLevel">80</integer>
 </resources>
diff --git a/core/res/res/values/havoc_strings.xml b/core/res/res/values/havoc_strings.xml
index acbe57ba1a1d..5e0bb3419364 100644
--- a/core/res/res/values/havoc_strings.xml
+++ b/core/res/res/values/havoc_strings.xml
@@ -205,7 +205,4 @@
     <string name="accessibility_quick_settings_live_display_changed_day">LiveDisplay changed to day mode.</string> 
     <string name="accessibility_quick_settings_live_display_changed_night">LiveDisplay changed to night mode.</string> 
     <string name="accessibility_quick_settings_live_display_changed_outdoor">LiveDisplay changed to outdoor mode.</string> 
-
-    <!-- Pocket Lock --> 
-    <string name="pocket_lock_message_long_press">Press and hold power button to unlock</string> 
 </resources>
diff --git a/core/res/res/values/havoc_symbols.xml b/core/res/res/values/havoc_symbols.xml
index 8c9570538dcc..12fcb5fbe731 100644
--- a/core/res/res/values/havoc_symbols.xml
+++ b/core/res/res/values/havoc_symbols.xml
@@ -191,6 +191,15 @@
   <java-symbol type="string" name="systemui_restart_title" />
   <java-symbol type="string" name="systemui_restart_message" />
 
+  <!-- Proximity check on screen on -->
+  <java-symbol type="bool" name="config_proximityCheckOnWake" />
+
+  <!-- Proximity check timeout -->
+  <java-symbol type="integer" name="config_proximityCheckTimeout" />
+
+  <!-- Proximity check on screen on default -->
+  <java-symbol type="bool" name="config_proximityCheckOnWakeEnabledByDefault" />
+
   <java-symbol type="string" name="config_comboNetworkLocationProvider" />
 
   <!-- Weather icons -->
@@ -376,15 +385,6 @@
   <java-symbol type="bool" name="config_filterDisplayModes" />
   <java-symbol type="array" name="config_displayModeMappings" />
 
-  <!-- Pocket Lock -->
-  <java-symbol type="layout" name="pocket_lock_view_layout" />
-  <java-symbol type="id" name="pocket_hint_container" />
-  <java-symbol type="id" name="pocket_hint_image" />
-  <java-symbol type="id" name="pocket_hint_message" />
-
-  <!-- Pocket bridge -->
-  <java-symbol type="string" name="config_pocketBridgeSysfsInpocket" />
-
   <!-- Smart charging battery percentage -->
   <java-symbol type="integer" name="config_smartChargingBatteryLevel" />
 </resources>
diff --git a/packages/SystemUI/src/com/android/keyguard/KeyguardHostView.java b/packages/SystemUI/src/com/android/keyguard/KeyguardHostView.java
index 6fa523371ebc..d1aaa341b6d9 100644
--- a/packages/SystemUI/src/com/android/keyguard/KeyguardHostView.java
+++ b/packages/SystemUI/src/com/android/keyguard/KeyguardHostView.java
@@ -107,10 +107,7 @@ public class KeyguardHostView extends FrameLayout implements SecurityCallback {
                            Settings.Secure.FACE_AUTO_UNLOCK, 0,
                            UserHandle.USER_CURRENT) == 1;
             if (userId != KeyguardUpdateMonitor.getCurrentUser()) return;
-            if (mKeyguardUpdateMonitor.getUserCanSkipBouncer(userId) &&
-                mKeyguardUpdateMonitor.getUserHasTrust(userId) &&
-                mKeyguardUpdateMonitor.isFaceTrusted() && mFaceAuto &&
-                !mKeyguardUpdateMonitor.isPocketLockVisible()) {
+            if (mKeyguardUpdateMonitor.getUserCanSkipBouncer(userId) && mKeyguardUpdateMonitor.getUserHasTrust(userId) && mKeyguardUpdateMonitor.isFaceTrusted() && mFaceAuto) {
                 dismiss(false, userId);
             }
         }
diff --git a/packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java b/packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java
index 6b065f1f58d1..a13243f8c1d9 100644
--- a/packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java
+++ b/packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java
@@ -64,8 +64,6 @@ import android.os.ServiceManager;
 import android.os.Trace;
 import android.os.UserHandle;
 import android.os.UserManager;
-import android.pocket.IPocketCallback;
-import android.pocket.PocketManager;
 import android.provider.Settings;
 import android.service.dreams.DreamService;
 import android.service.dreams.IDreamManager;
@@ -248,7 +246,6 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener,
     private boolean mIsDreaming;
     private final DevicePolicyManager mDevicePolicyManager;
     private boolean mLogoutEnabled;
-    private boolean mPocketJudgeAllowFP;
 
     /**
      * Short delay before restarting fingerprint authentication after a successful try
@@ -265,31 +262,6 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener,
     // For face unlock identification
     private String lastBroadcastActionReceived;
 
-    private PocketManager mPocketManager;
-    private boolean mIsDeviceInPocket;
-    private final IPocketCallback mPocketCallback = new IPocketCallback.Stub() {
-        @Override
-        public void onStateChanged(boolean isDeviceInPocket, int reason) {
-            boolean changed = false;
-            if (reason == PocketManager.REASON_SENSOR) {
-                if (isDeviceInPocket != mIsDeviceInPocket) {
-                    mIsDeviceInPocket = isDeviceInPocket;
-                    changed = true;
-                }
-            } else {
-                changed = isDeviceInPocket != mIsDeviceInPocket;
-                mIsDeviceInPocket = false;
-            }
-            if (changed) {
-                mHandler.sendEmptyMessage(MSG_POCKET_STATE_CHANGED);
-            }
-        }
-    };
-
-    public boolean isPocketLockVisible(){
-        return mPocketManager.isPocketLockVisible();
-    }
-
     private final Handler mHandler = new Handler(Looper.getMainLooper()) {
         @Override
         public void handleMessage(Message msg) {
@@ -388,9 +360,6 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener,
                 case MSG_TELEPHONY_CAPABLE:
                     updateTelephonyCapable((boolean)msg.obj);
                     break;
-                case MSG_POCKET_STATE_CHANGED:
-                    updateFingerprintListeningState();
-                    break;
                 default:
                     super.handleMessage(msg);
                     break;
@@ -1330,11 +1299,6 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener,
         mDreamManager = IDreamManager.Stub.asInterface(
                 ServiceManager.getService(DreamService.DREAM_SERVICE));
 
-        mPocketManager = (PocketManager) context.getSystemService(Context.POCKET_SERVICE);
-        if (mPocketManager != null) {
-            mPocketManager.addCallback(mPocketCallback);
-        }
-
         if (mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_FINGERPRINT)) {
             mFpm = (FingerprintManager) context.getSystemService(Context.FINGERPRINT_SERVICE);
         }
@@ -1383,21 +1347,11 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener,
     }
 
     private boolean shouldListenForFingerprint() {
-        mPocketJudgeAllowFP = Settings.System.getIntForUser(mContext.getContentResolver(),
-                Settings.System.POCKET_JUDGE_ALLOW_FP, 0, UserHandle.USER_CURRENT) == 1;
-        if (!mPocketJudgeAllowFP) {
-            return (mKeyguardIsVisible || !mDeviceInteractive ||
-                    (mBouncer && !mKeyguardGoingAway) || mGoingToSleep ||
-                    shouldListenForFingerprintAssistant() || (mKeyguardOccluded && mIsDreaming))
-                    && !mSwitchingUser && !isFingerprintDisabled(getCurrentUser())
-                    && !mKeyguardGoingAway && !mIsDeviceInPocket;
-        } else {
-            return (mKeyguardIsVisible || !mDeviceInteractive ||
-                    (mBouncer && !mKeyguardGoingAway) || mGoingToSleep ||
-                    shouldListenForFingerprintAssistant() || (mKeyguardOccluded && mIsDreaming))
-                    && !mSwitchingUser && !isFingerprintDisabled(getCurrentUser())
-                    && !mKeyguardGoingAway;
-        }
+        return (mKeyguardIsVisible || !mDeviceInteractive ||
+                (mBouncer && !mKeyguardGoingAway) || mGoingToSleep ||
+                shouldListenForFingerprintAssistant() || (mKeyguardOccluded && mIsDreaming))
+                && !mSwitchingUser && !isFingerprintDisabled(getCurrentUser())
+                && !mKeyguardGoingAway;
     }
 
     private void startListeningForFingerprint() {
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBar.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBar.java
index b638592ae06b..7cd9d1445d16 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBar.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBar.java
@@ -685,8 +685,6 @@ public class StatusBar extends SystemUI implements DemoMode,
 
     private boolean mWallpaperSupportsAmbientMode;
 
-    private boolean mPocketJudgeAllowFP;
-
     private BroadcastReceiver mWallpaperChangedReceiver = new BroadcastReceiver() {
         @Override
         public void onReceive(Context context, Intent intent) {
@@ -5746,9 +5744,6 @@ public class StatusBar extends SystemUI implements DemoMode,
             resolver.registerContentObserver(Settings.System.getUriFor(
                   Settings.System.LOCKSCREEN_ALBUM_ART_FILTER),
                   false, this, UserHandle.USER_ALL);
-            resolver.registerContentObserver(Settings.System.getUriFor(
-                    Settings.System.POCKET_JUDGE_ALLOW_FP),
-                    false, this, UserHandle.USER_ALL);
 	    }
 
         @Override
@@ -5853,9 +5848,6 @@ public class StatusBar extends SystemUI implements DemoMode,
             } else if (uri.equals(Settings.System.getUriFor(
                     Settings.System.USE_OLD_MOBILETYPE))) {
                 updateTelephonyIcons();
-            } else if (uri.equals(Settings.System.getUriFor(
-                    Settings.System.POCKET_JUDGE_ALLOW_FP))) {
-                updatePocketJudgeFP();
             }
         }
 
@@ -5878,7 +5870,6 @@ public class StatusBar extends SystemUI implements DemoMode,
             updateKeyguardStatusBarSettings();
             updateLockscreenFilter();
             updateTelephonyIcons();
-            updatePocketJudgeFP();
         }
     }
 
@@ -6034,11 +6025,6 @@ public class StatusBar extends SystemUI implements DemoMode,
         TelephonyIcons.updateIcons(USE_OLD_MOBILETYPE);
     }
 
-    private void updatePocketJudgeFP() {
-        mPocketJudgeAllowFP = Settings.System.getIntForUser(mContext.getContentResolver(),
-                Settings.System.POCKET_JUDGE_ALLOW_FP, 0, UserHandle.USER_CURRENT) == 1;
-    }
-
     public int getWakefulnessState() {
         return mWakefulnessLifecycle.getWakefulness();
     }
diff --git a/services/core/java/com/android/server/pocket/PocketBridgeService.java b/services/core/java/com/android/server/pocket/PocketBridgeService.java
deleted file mode 100644
index f57bf0540362..000000000000
--- a/services/core/java/com/android/server/pocket/PocketBridgeService.java
+++ /dev/null
@@ -1,177 +0,0 @@
-/**
- * Copyright (C) 2017 The ParanoidAndroid Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.server.pocket;
-
-import java.io.FileNotFoundException;
-import java.io.FileOutputStream;
-
-import android.content.Context;
-import android.database.ContentObserver;
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.os.Looper;
-import android.os.Message;
-import android.os.Process;
-import android.os.UserHandle;
-import android.pocket.IPocketCallback;
-import android.pocket.PocketManager;
-import android.provider.Settings.System;
-import android.util.Slog;
-import com.android.internal.util.FastPrintWriter;
-import com.android.server.SystemService;
-
-import static android.provider.Settings.System.POCKET_JUDGE;
-
-/**
- * This service communicates pocket state to the pocket judge kernel driver.
- * It maintains the pocket state by binding to the pocket service.
- *
- * @author Chris Lahaye
- * @hide
- */
-public class PocketBridgeService extends SystemService {
-
-    private static final String TAG = PocketBridgeService.class.getSimpleName();
-    private static final int MSG_POCKET_STATE_CHANGED = 1;
-
-    private Context mContext;
-    private boolean mEnabled;
-    private PocketBridgeHandler mHandler;
-    private PocketBridgeObserver mObserver;
-
-    private PocketManager mPocketManager;
-    private boolean mIsDeviceInPocket;
-    private final IPocketCallback mPocketCallback = new IPocketCallback.Stub() {
-        @Override
-        public void onStateChanged(boolean isDeviceInPocket, int reason) {
-            boolean changed = false;
-            if (reason == PocketManager.REASON_SENSOR) {
-                if (isDeviceInPocket != mIsDeviceInPocket) {
-                    mIsDeviceInPocket = isDeviceInPocket;
-                    changed = true;
-                }
-            } else {
-                changed = isDeviceInPocket != mIsDeviceInPocket;
-                mIsDeviceInPocket = false;
-            }
-            if (changed) {
-                mHandler.sendEmptyMessage(MSG_POCKET_STATE_CHANGED);
-            }
-        }
-    };
-
-    public PocketBridgeService(Context context) {
-        super(context);
-        mContext = context;
-        HandlerThread handlerThread = new HandlerThread(TAG, Process.THREAD_PRIORITY_BACKGROUND);
-        handlerThread.start();
-        mHandler = new PocketBridgeHandler(handlerThread.getLooper());
-        mPocketManager = (PocketManager)
-                context.getSystemService(Context.POCKET_SERVICE);
-        mObserver = new PocketBridgeObserver(mHandler);
-        mObserver.onChange(true);
-        mObserver.register();
-    }
-
-    @Override
-    public void onStart() {
-    }
-
-    private void setEnabled(boolean enabled) {
-        if (enabled != mEnabled) {
-            mEnabled = enabled;
-            update();
-        }
-    }
-
-    private void update() {
-        if (mPocketManager == null) return;
-
-        if (mEnabled) {
-            mPocketManager.addCallback(mPocketCallback);
-        } else {
-            mPocketManager.removeCallback(mPocketCallback);
-        }
-    }
-
-    private class PocketBridgeHandler extends Handler {
-
-        private FileOutputStream mFileOutputStream;
-        private FastPrintWriter mPrintWriter;
-
-        public PocketBridgeHandler(Looper looper) {
-            super(looper);
-
-            try {
-                mFileOutputStream = new FileOutputStream(
-                    mContext.getResources().getString(
-                        com.android.internal.R.string.config_pocketBridgeSysfsInpocket)
-                );
-                mPrintWriter = new FastPrintWriter(mFileOutputStream, true, 128);
-            }
-            catch(FileNotFoundException e) {
-                Slog.w(TAG, "Pocket bridge error occured", e);
-                setEnabled(false);
-            }
-        }
-
-        @Override
-        public void handleMessage(android.os.Message msg) {
-            if (msg.what != MSG_POCKET_STATE_CHANGED) {
-                Slog.w(TAG, "Unknown message:" + msg.what);
-                return;
-            }
-
-            if (mPrintWriter != null) {
-                mPrintWriter.println(mIsDeviceInPocket ? 1 : 0);
-            }
-        }
-
-    }
-
-    private class PocketBridgeObserver extends ContentObserver {
-
-        private boolean mRegistered;
-
-        public PocketBridgeObserver(Handler handler) {
-            super(handler);
-        }
-
-        @Override
-        public void onChange(boolean selfChange) {
-            final boolean enabled = System.getIntForUser(mContext.getContentResolver(),
-                    POCKET_JUDGE, 0 /* default */, UserHandle.USER_CURRENT) != 0;
-            setEnabled(enabled);
-        }
-
-        public void register() {
-            if (!mRegistered) {
-                mContext.getContentResolver().registerContentObserver(
-                        System.getUriFor(POCKET_JUDGE), true, this);
-                mRegistered = true;
-            }
-        }
-
-        public void unregister() {
-            if (mRegistered) {
-                mContext.getContentResolver().unregisterContentObserver(this);
-                mRegistered = false;
-            }
-        }
-
-    }
-
-}
diff --git a/services/core/java/com/android/server/pocket/PocketService.java b/services/core/java/com/android/server/pocket/PocketService.java
deleted file mode 100644
index 9be31830e1bc..000000000000
--- a/services/core/java/com/android/server/pocket/PocketService.java
+++ /dev/null
@@ -1,751 +0,0 @@
-/**
- * Copyright (C) 2016 The ParanoidAndroid Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.server.pocket;
-
-import android.Manifest;
-import android.content.Context;
-import android.content.pm.PackageManager;
-import android.database.ContentObserver;
-import android.hardware.Sensor;
-import android.hardware.SensorEvent;
-import android.hardware.SensorEventListener;
-import android.hardware.SensorManager;
-import android.os.Binder;
-import android.os.DeadObjectException;
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.os.IBinder;
-import android.os.Looper;
-import android.os.Message;
-import android.os.Process;
-import android.os.RemoteException;
-import android.os.SystemClock;
-import android.os.UserHandle;
-import android.pocket.IPocketService;
-import android.pocket.IPocketCallback;
-import android.pocket.PocketConstants;
-import android.pocket.PocketManager;
-import android.provider.Settings.System;
-import android.util.Log;
-import android.util.Slog;
-
-import com.android.server.SystemService;
-
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import java.io.FileDescriptor;
-import java.io.PrintWriter;
-import java.util.ArrayList;
-
-import static android.provider.Settings.System.POCKET_JUDGE;
-
-/**
- * A service to manage multiple clients that want to listen for pocket state.
- * The service is responsible for maintaining a list of clients and dispatching all
- * pocket -related information.
- *
- * @author Carlo Savignano
- * @hide
- */
-public class PocketService extends SystemService implements IBinder.DeathRecipient {
-
-    private static final String TAG = PocketService.class.getSimpleName();
-    private static final boolean DEBUG = PocketConstants.DEBUG;
-
-    /**
-     * The rate proximity sensor events are delivered at.
-     */
-    private static final int PROXIMITY_SENSOR_DELAY = 400000;
-
-    /**
-     * Wheater we don't have yet a valid proximity sensor event or pocket service not running.
-     */
-    private static final int PROXIMITY_UNKNOWN = 0;
-
-    /**
-     * Proximity sensor has been registered, onSensorChanged() has been called and we have a
-     * valid event value which determined proximity sensor is covered.
-     */
-    private static final int PROXIMITY_POSITIVE = 1;
-
-    /**
-     * Proximity sensor has been registered, onSensorChanged() has been called and we have a
-     * valid event value which determined proximity sensor is not covered.
-     */
-    private static final int PROXIMITY_NEGATIVE = 2;
-
-    /**
-     * The rate light sensor events are delivered at.
-     */
-    private static final int LIGHT_SENSOR_DELAY = 400000;
-
-    /**
-     * Wheater we don't have yet a valid light sensor event or pocket service not running.
-     */
-    private static final int LIGHT_UNKNOWN = 0;
-
-    /**
-     * Light sensor has been registered, onSensorChanged() has been called and we have a
-     * valid event value which determined available light is in pocket range.
-     */
-    private static final int LIGHT_POCKET = 1;
-
-    /**
-     * Light sensor has been registered, onSensorChanged() has been called and we have a
-     * valid event value which determined available light is outside pocket range.
-     */
-    private static final int LIGHT_AMBIENT = 2;
-
-    /**
-     * Light sensor maximum value registered in pocket with up to semi-transparent fabric.
-     */
-    private static final float POCKET_LIGHT_MAX_THRESHOLD = 3.0f;
-
-    private final ArrayList<IPocketCallback> mCallbacks= new ArrayList<>();
-
-    private Context mContext;
-    private boolean mEnabled;
-    private boolean mSystemReady;
-    private boolean mSystemBooted;
-    private boolean mInteractive;
-    private boolean mPending;
-    private PocketHandler mHandler;
-    private PocketObserver mObserver;
-    private SensorManager mSensorManager;
-
-    // proximity
-    private int mProximityState = PROXIMITY_UNKNOWN;
-    private int mLastProximityState = PROXIMITY_UNKNOWN;
-    private float mProximityMaxRange;
-    private boolean mProximityRegistered;
-    private Sensor mProximitySensor;
-
-    // light
-    private int mLightState = LIGHT_UNKNOWN;
-    private int mLastLightState = LIGHT_UNKNOWN;
-    private float mLightMaxRange;
-    private boolean mLightRegistered;
-    private Sensor mLightSensor;
-
-    // Custom methods
-    private boolean mPocketLockVisible;
-
-    public PocketService(Context context) {
-        super(context);
-        mContext = context;
-        HandlerThread handlerThread = new HandlerThread(TAG, Process.THREAD_PRIORITY_BACKGROUND);
-        handlerThread.start();
-        mHandler = new PocketHandler(handlerThread.getLooper());
-        mSensorManager = (SensorManager) mContext.getSystemService(Context.SENSOR_SERVICE);
-        mProximitySensor = mSensorManager.getDefaultSensor(Sensor.TYPE_PROXIMITY);
-        if (mProximitySensor != null) {
-            mProximityMaxRange = mProximitySensor.getMaximumRange();
-        }
-        mLightSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_LIGHT);
-        if (mLightSensor != null) {
-            mLightMaxRange = mLightSensor.getMaximumRange();
-        }
-        mObserver = new PocketObserver(mHandler);
-        mObserver.onChange(true);
-        mObserver.register();
-    }
-
-    private class PocketObserver extends ContentObserver {
-
-        private boolean mRegistered;
-
-        public PocketObserver(Handler handler) {
-            super(handler);
-        }
-
-        @Override
-        public void onChange(boolean selfChange) {
-            final boolean enabled = System.getIntForUser(mContext.getContentResolver(),
-                    POCKET_JUDGE, 0 /* default */, UserHandle.USER_CURRENT) != 0;
-            setEnabled(enabled);
-        }
-
-        public void register() {
-            if (!mRegistered) {
-                mContext.getContentResolver().registerContentObserver(
-                        System.getUriFor(POCKET_JUDGE), true, this);
-                mRegistered = true;
-            }
-        }
-
-        public void unregister() {
-            if (mRegistered) {
-                mContext.getContentResolver().unregisterContentObserver(this);
-                mRegistered = false;
-            }
-        }
-
-    }
-
-    private class PocketHandler extends Handler {
-
-        public static final int MSG_SYSTEM_READY = 0;
-        public static final int MSG_SYSTEM_BOOTED = 1;
-        public static final int MSG_DISPATCH_CALLBACKS = 2;
-        public static final int MSG_ADD_CALLBACK = 3;
-        public static final int MSG_REMOVE_CALLBACK = 4;
-        public static final int MSG_INTERACTIVE_CHANGED = 5;
-        public static final int MSG_SENSOR_EVENT_PROXIMITY = 6;
-        public static final int MSG_SENSOR_EVENT_LIGHT = 7;
-        public static final int MSG_UNREGISTER_TIMEOUT = 8;
-        public static final int MSG_SET_LISTEN_EXTERNAL = 9;
-        public static final int MSG_SET_POCKET_LOCK_VISIBLE = 10;
-
-        public PocketHandler(Looper looper) {
-            super(looper);
-        }
-
-        @Override
-        public void handleMessage(android.os.Message msg) {
-            switch (msg.what) {
-                case MSG_SYSTEM_READY:
-                    handleSystemReady();
-                    break;
-                case MSG_SYSTEM_BOOTED:
-                    handleSystemBooted();
-                    break;
-                case MSG_DISPATCH_CALLBACKS:
-                    handleDispatchCallbacks();
-                    break;
-                case MSG_ADD_CALLBACK:
-                    handleAddCallback((IPocketCallback) msg.obj);
-                    break;
-                case MSG_REMOVE_CALLBACK:
-                    handleRemoveCallback((IPocketCallback) msg.obj);
-                    break;
-                case MSG_INTERACTIVE_CHANGED:
-                    handleInteractiveChanged(msg.arg1 != 0);
-                    break;
-                case MSG_SENSOR_EVENT_PROXIMITY:
-                    handleProximitySensorEvent((SensorEvent) msg.obj);
-                    break;
-                case MSG_SENSOR_EVENT_LIGHT:
-                    handleLightSensorEvent((SensorEvent) msg.obj);
-                    break;
-                case MSG_UNREGISTER_TIMEOUT:
-                    handleUnregisterTimeout();
-                    break;
-                case MSG_SET_LISTEN_EXTERNAL:
-                    handleSetListeningExternal(msg.arg1 != 0);
-                    break;
-                case MSG_SET_POCKET_LOCK_VISIBLE:
-                    handleSetPocketLockVisible(msg.arg1 != 0);
-                    break;
-                default:
-                    Slog.w(TAG, "Unknown message:" + msg.what);
-            }
-        }
-    }
-
-    @Override
-    public void onBootPhase(int phase) {
-        switch(phase) {
-            case PHASE_SYSTEM_SERVICES_READY:
-                mHandler.sendEmptyMessage(PocketHandler.MSG_SYSTEM_READY);
-                break;
-            case PHASE_BOOT_COMPLETED:
-                mHandler.sendEmptyMessage(PocketHandler.MSG_SYSTEM_BOOTED);
-                break;
-            default:
-                Slog.w(TAG, "Un-handled boot phase:" + phase);
-                break;
-        }
-    }
-
-    @Override
-    public void onStart() {
-        publishBinderService(Context.POCKET_SERVICE, new PocketServiceWrapper());
-    }
-
-    @Override
-    public void binderDied() {
-        synchronized (mCallbacks) {
-            mProximityState = PROXIMITY_UNKNOWN;
-            int callbacksSize = mCallbacks.size();
-            for (int i = callbacksSize - 1; i >= 0; i--) {
-                if (mCallbacks.get(i) != null) {
-                    try {
-                        mCallbacks.get(i).onStateChanged(false, PocketManager.REASON_RESET);
-                    } catch (DeadObjectException e) {
-                        Slog.w(TAG, "Death object while invoking sendPocketState: ", e);
-                    } catch (RemoteException e) {
-                        Slog.w(TAG, "Failed to invoke sendPocketState: ", e);
-                    }
-                }
-            }
-            mCallbacks.clear();
-        }
-        unregisterSensorListeners();
-        mObserver.unregister();
-    }
-
-    private final class PocketServiceWrapper extends IPocketService.Stub {
-
-        @Override // Binder call
-        public void addCallback(final IPocketCallback callback) {
-            final Message msg = new Message();
-            msg.what = PocketHandler.MSG_ADD_CALLBACK;
-            msg.obj = callback;
-            mHandler.sendMessage(msg);
-        }
-
-        @Override // Binder call
-        public void removeCallback(final IPocketCallback callback) {
-            final Message msg = new Message();
-            msg.what = PocketHandler.MSG_REMOVE_CALLBACK;
-            msg.obj = callback;
-            mHandler.sendMessage(msg);
-        }
-
-        @Override // Binder call
-        public void onInteractiveChanged(final boolean interactive) {
-            final Message msg = new Message();
-            msg.what = PocketHandler.MSG_INTERACTIVE_CHANGED;
-            msg.arg1 = interactive ? 1 : 0;
-            mHandler.sendMessage(msg);
-        }
-
-        @Override // Binder call
-        public void setListeningExternal(final boolean listen) {
-            final Message msg = new Message();
-            msg.what = PocketHandler.MSG_SET_LISTEN_EXTERNAL;
-            msg.arg1 = listen ? 1 : 0;
-            mHandler.sendMessage(msg);
-        }
-
-        @Override // Binder call
-        public boolean isDeviceInPocket() {
-            final long ident = Binder.clearCallingIdentity();
-            try {
-                if (!mSystemReady || !mSystemBooted) {
-                    return false;
-                }
-                return PocketService.this.isDeviceInPocket();
-            } finally {
-                Binder.restoreCallingIdentity(ident);
-            }
-        }
-
-        @Override // Binder call
-        public void setPocketLockVisible(final boolean visible) {
-            final Message msg = new Message();
-            msg.what = PocketHandler.MSG_SET_POCKET_LOCK_VISIBLE;
-            msg.arg1 = visible ? 1 : 0;
-            mHandler.sendMessage(msg);
-        }
-
-        @Override // Binder call
-        public boolean isPocketLockVisible() {
-            final long ident = Binder.clearCallingIdentity();
-            try {
-                if (!mSystemReady || !mSystemBooted) {
-                    return false;
-                }
-                return PocketService.this.isPocketLockVisible();
-            } finally {
-                Binder.restoreCallingIdentity(ident);
-            }
-        }
-
-        @Override // Binder call
-        protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
-            if (mContext.checkCallingOrSelfPermission(Manifest.permission.DUMP)
-                    != PackageManager.PERMISSION_GRANTED) {
-                pw.println("Permission Denial: can't dump Pocket from from pid="
-                        + Binder.getCallingPid()
-                        + ", uid=" + Binder.getCallingUid());
-                return;
-            }
-
-            final long ident = Binder.clearCallingIdentity();
-            try {
-                dumpInternal(pw);
-            } finally {
-                Binder.restoreCallingIdentity(ident);
-            }
-        }
-
-    }
-
-    private final SensorEventListener mProximityListener = new SensorEventListener() {
-        @Override
-        public void onSensorChanged(SensorEvent sensorEvent) {
-            final Message msg = new Message();
-            msg.what = PocketHandler.MSG_SENSOR_EVENT_PROXIMITY;
-            msg.obj = sensorEvent;
-            mHandler.sendMessage(msg);
-        }
-
-        @Override
-        public void onAccuracyChanged(Sensor sensor, int i) { }
-    };
-
-    private final SensorEventListener mLightListener = new SensorEventListener() {
-        @Override
-        public void onSensorChanged(SensorEvent sensorEvent) {
-            final Message msg = new Message();
-            msg.what = PocketHandler.MSG_SENSOR_EVENT_LIGHT;
-            msg.obj = sensorEvent;
-            mHandler.sendMessage(msg);
-        }
-
-        @Override
-        public void onAccuracyChanged(Sensor sensor, int i) { }
-    };
-
-    private boolean isDeviceInPocket() {
-        if (mLightState != LIGHT_UNKNOWN) {
-            return mProximityState == PROXIMITY_POSITIVE
-                    && mLightState == LIGHT_POCKET;
-        }
-        return mProximityState == PROXIMITY_POSITIVE;
-    }
-
-    private void setEnabled(boolean enabled) {
-        if (enabled != mEnabled) {
-            mEnabled = enabled;
-            mHandler.removeCallbacksAndMessages(null);
-            update();
-        }
-    }
-
-    private void update() {
-        if (!mEnabled || mInteractive) {
-            if (mEnabled && isDeviceInPocket()) {
-                // if device is judged to be in pocket while switching
-                // to interactive state, we need to keep monitoring.
-                return;
-            }
-            unregisterSensorListeners();
-        } else {
-            mHandler.removeMessages(PocketHandler.MSG_UNREGISTER_TIMEOUT);
-            registerSensorListeners();
-        }
-    }
-
-    private void registerSensorListeners() {
-        startListeningForProximity();
-        startListeningForLight();
-    }
-
-    private void unregisterSensorListeners() {
-        stopListeningForProximity();
-        stopListeningForLight();
-    }
-
-    private void startListeningForProximity() {
-        if (DEBUG) {
-            Log.d(TAG, "startListeningForProximity()");
-        }
-
-        if (!PocketConstants.ENABLE_PROXIMITY_JUDGE) {
-            return;
-        }
-
-        if (mProximitySensor == null) {
-            Log.d(TAG, "Cannot detect proximity sensor, sensor is NULL");
-            return;
-        }
-
-        if (!mProximityRegistered) {
-            mSensorManager.registerListener(mProximityListener, mProximitySensor,
-                    PROXIMITY_SENSOR_DELAY, mHandler);
-            mProximityRegistered = true;
-        }
-    }
-
-    private void stopListeningForProximity() {
-        if (DEBUG) {
-            Log.d(TAG, "startListeningForProximity()");
-        }
-
-        if (mProximityRegistered) {
-            mLastProximityState = mProximityState = PROXIMITY_UNKNOWN;
-            mSensorManager.unregisterListener(mProximityListener);
-            mProximityRegistered = false;
-        }
-    }
-
-    private void startListeningForLight() {
-        if (DEBUG) {
-            Log.d(TAG, "startListeningForLight()");
-        }
-
-        if (!PocketConstants.ENABLE_LIGHT_JUDGE) {
-            return;
-        }
-
-        if (mLightSensor == null) {
-            Log.d(TAG, "Cannot detect light sensor, sensor is NULL");
-            return;
-        }
-
-        if (!mLightRegistered) {
-            mSensorManager.registerListener(mLightListener, mLightSensor,
-                    LIGHT_SENSOR_DELAY, mHandler);
-            mLightRegistered = true;
-        }
-    }
-
-    private void stopListeningForLight() {
-        if (DEBUG) {
-            Log.d(TAG, "stopListeningForLight()");
-        }
-
-        if (mLightRegistered) {
-            mLightState = mLastLightState = LIGHT_UNKNOWN;
-            mSensorManager.unregisterListener(mLightListener);
-            mLightRegistered = false;
-        }
-    }
-
-    private void handleSystemReady() {
-        if (DEBUG) {
-            Log.d(TAG, "onBootPhase(): PHASE_SYSTEM_SERVICES_READY");
-        }
-        mSystemReady = true;
-        if (mPending) {
-            final Message msg = new Message();
-            msg.what = PocketHandler.MSG_INTERACTIVE_CHANGED;
-            msg.arg1 = mInteractive ? 1 : 0;
-            mHandler.sendMessage(msg);
-            mPending = false;
-        }
-    }
-
-    private void handleSystemBooted() {
-        if (DEBUG) {
-            Log.d(TAG, "onBootPhase(): PHASE_BOOT_COMPLETED");
-        }
-        mSystemBooted = true;
-        if (mPending) {
-            final Message msg = new Message();
-            msg.what = PocketHandler.MSG_INTERACTIVE_CHANGED;
-            msg.arg1 = mInteractive ? 1 : 0;
-            mHandler.sendMessage(msg);
-            mPending = false;
-        }
-    }
-
-    private void handleDispatchCallbacks() {
-        synchronized (mCallbacks) {
-            final int N = mCallbacks.size();
-            boolean cleanup = false;
-            for (int i = 0; i < N; i++) {
-                final IPocketCallback callback = mCallbacks.get(i);
-                try {
-                    if (callback != null) {
-                        callback.onStateChanged(isDeviceInPocket(), PocketManager.REASON_SENSOR);
-                    } else {
-                        cleanup = true;
-                    }
-                } catch (RemoteException e) {
-                    cleanup = true;
-                }
-            }
-            if (cleanup) {
-                cleanUpCallbacksLocked(null);
-            }
-        }
-    }
-
-    private void cleanUpCallbacksLocked(IPocketCallback callback) {
-        synchronized (mCallbacks) {
-            for (int i = mCallbacks.size() - 1; i >= 0; i--) {
-                IPocketCallback found = mCallbacks.get(i);
-                if (found == null || found == callback) {
-                    mCallbacks.remove(i);
-                }
-            }
-        }
-    }
-
-    private void handleSetPocketLockVisible(boolean visible) {
-        mPocketLockVisible = visible;
-    }
-
-    private boolean isPocketLockVisible() {
-        return mPocketLockVisible;
-    }
-
-    private void handleSetListeningExternal(boolean listen) {
-        if (listen) {
-            // should prevent external processes to register while interactive,
-            // while they are allowed to stop listening in any case as for example
-            // coming pocket lock will need to.
-            if (!mInteractive) {
-                registerSensorListeners();
-            }
-        } else {
-            mHandler.removeCallbacksAndMessages(null);
-            unregisterSensorListeners();
-        }
-        dispatchCallbacks();
-    }
-
-    private void handleAddCallback(IPocketCallback callback) {
-        synchronized (mCallbacks) {
-            if (!mCallbacks.contains(callback)) {
-                mCallbacks.add(callback);
-            }
-        }
-    }
-
-    private void handleRemoveCallback(IPocketCallback callback) {
-        synchronized (mCallbacks) {
-            if (mCallbacks.contains(callback)) {
-                mCallbacks.remove(callback);
-            }
-        }
-    }
-
-    private void handleInteractiveChanged(boolean interactive) {
-        // always update interactive state.
-        mInteractive = interactive;
-
-        if (mPending) {
-            // working on it, waiting for proper system conditions.
-            return;
-        } else if (!mPending && (!mSystemBooted || !mSystemReady)) {
-            // we ain't ready, postpone till system is both booted AND ready.
-            mPending = true;
-            return;
-        }
-
-        update();
-    }
-
-    private void handleLightSensorEvent(SensorEvent sensorEvent) {
-        final boolean isDeviceInPocket = isDeviceInPocket();
-
-        mLastLightState = mLightState;
-
-        if (DEBUG) {
-            final String sensorEventToString = sensorEvent != null ? sensorEvent.toString() : "NULL";
-            Log.d(TAG, "LIGHT_SENSOR: onSensorChanged(), sensorEvent =" + sensorEventToString);
-        }
-
-        try {
-            if (sensorEvent == null) {
-                if (DEBUG) Log.d(TAG, "Event is null!");
-                mLightState = LIGHT_UNKNOWN;
-            } else if (sensorEvent.values == null || sensorEvent.values.length == 0) {
-                if (DEBUG) Log.d(TAG, "Event has no values! event.values null ? " + (sensorEvent.values == null));
-                mLightState = LIGHT_UNKNOWN;
-            } else {
-                final float value = sensorEvent.values[0];
-                final boolean isPoor = value >= 0
-                        && value <= POCKET_LIGHT_MAX_THRESHOLD;
-                if (DEBUG) {
-                    final long time = SystemClock.uptimeMillis();
-                    Log.d(TAG, "Event: time= " + time + ", value=" + value
-                            + ", maxRange=" + mLightMaxRange + ", isPoor=" + isPoor);
-                }
-                mLightState = isPoor ? LIGHT_POCKET : LIGHT_AMBIENT;
-            }
-        } catch (NullPointerException e) {
-            Log.e(TAG, "Event: something went wrong, exception caught, e = " + e);
-            mLightState = LIGHT_UNKNOWN;
-        } finally {
-            if (isDeviceInPocket != isDeviceInPocket()) {
-                dispatchCallbacks();
-            }
-        }
-    }
-
-    private void handleProximitySensorEvent(SensorEvent sensorEvent) {
-        final boolean isDeviceInPocket = isDeviceInPocket();
-
-        mLastProximityState = mProximityState;
-
-        if (DEBUG) {
-            final String sensorEventToString = sensorEvent != null ? sensorEvent.toString() : "NULL";
-            Log.d(TAG, "PROXIMITY_SENSOR: onSensorChanged(), sensorEvent =" + sensorEventToString);
-        }
-
-        try {
-            if (sensorEvent == null) {
-                if (DEBUG) Log.d(TAG, "Event is null!");
-                mProximityState = PROXIMITY_UNKNOWN;
-            } else if (sensorEvent.values == null || sensorEvent.values.length == 0) {
-                if (DEBUG) Log.d(TAG, "Event has no values! event.values null ? " + (sensorEvent.values == null));
-                mProximityState = PROXIMITY_UNKNOWN;
-            } else {
-                final float value = sensorEvent.values[0];
-                final boolean isPositive = sensorEvent.values[0] < mProximityMaxRange;
-                if (DEBUG) {
-                    final long time = SystemClock.uptimeMillis();
-                    Log.d(TAG, "Event: time=" + time + ", value=" + value
-                            + ", maxRange=" + mProximityMaxRange + ", isPositive=" + isPositive);
-                }
-                mProximityState = isPositive ? PROXIMITY_POSITIVE : PROXIMITY_NEGATIVE;
-            }
-        } catch (NullPointerException e) {
-            Log.e(TAG, "Event: something went wrong, exception caught, e = " + e);
-            mProximityState = PROXIMITY_UNKNOWN;
-        } finally {
-            if (isDeviceInPocket != isDeviceInPocket()) {
-                dispatchCallbacks();
-            }
-        }
-    }
-
-    private void handleUnregisterTimeout() {
-        mHandler.removeCallbacksAndMessages(null);
-        unregisterSensorListeners();
-    }
-
-    private void dispatchCallbacks() {
-        final boolean isDeviceInPocket = isDeviceInPocket();
-        if (mInteractive) {
-            if (!isDeviceInPocket) {
-                mHandler.sendEmptyMessageDelayed(PocketHandler.MSG_UNREGISTER_TIMEOUT, 5000 /* ms */);
-            } else {
-                mHandler.removeMessages(PocketHandler.MSG_UNREGISTER_TIMEOUT);
-            }
-        }
-        mHandler.removeMessages(PocketHandler.MSG_DISPATCH_CALLBACKS);
-        mHandler.sendEmptyMessage(PocketHandler.MSG_DISPATCH_CALLBACKS);
-    }
-
-    private void dumpInternal(PrintWriter pw) {
-        JSONObject dump = new JSONObject();
-        try {
-            dump.put("service", "POCKET");
-            dump.put("enabled", mEnabled);
-            dump.put("isDeviceInPocket", isDeviceInPocket());
-            dump.put("interactive", mInteractive);
-            dump.put("proximityState", mProximityState);
-            dump.put("lastProximityState", mLastProximityState);
-            dump.put("proximityRegistered", mProximityRegistered);
-            dump.put("proximityMaxRange", mProximityMaxRange);
-            dump.put("lightState", mLightState);
-            dump.put("lastLightState", mLastLightState);
-            dump.put("lightRegistered", mLightRegistered);
-            dump.put("lightMaxRange", mLightMaxRange);
-        } catch (JSONException e) {
-            Slog.e(TAG, "dump formatting failure", e);
-        } finally {
-            pw.println(dump);
-        }
-    }
-}
diff --git a/services/core/java/com/android/server/policy/ImmersiveModeConfirmation.java b/services/core/java/com/android/server/policy/ImmersiveModeConfirmation.java
index aa23da053a17..dfbc2c73d400 100644
--- a/services/core/java/com/android/server/policy/ImmersiveModeConfirmation.java
+++ b/services/core/java/com/android/server/policy/ImmersiveModeConfirmation.java
@@ -83,7 +83,6 @@ public class ImmersiveModeConfirmation {
     // the lock held.
     boolean mVrModeEnabled = false;
     private int mLockTaskState = LOCK_TASK_MODE_NONE;
-    private boolean mIsDeviceInPocket = false;
 
     public ImmersiveModeConfirmation(Context context) {
         mContext = ActivityThread.currentActivityThread().getSystemUiContext();
@@ -155,8 +154,7 @@ public class ImmersiveModeConfirmation {
                     && !mVrModeEnabled
                     && !navBarEmpty
                     && !UserManager.isDeviceInDemoMode(mContext)
-                    && (mLockTaskState != LOCK_TASK_MODE_LOCKED)
-                    && !mIsDeviceInPocket) {
+                    && (mLockTaskState != LOCK_TASK_MODE_LOCKED)) {
                 mHandler.sendEmptyMessageDelayed(H.SHOW, mShowDelayMs);
             }
         } else {
@@ -418,8 +416,4 @@ public class ImmersiveModeConfirmation {
     void onLockTaskModeChangedLw(int lockTaskState) {
         mLockTaskState = lockTaskState;
     }
-
-    void onDevicePocketStateChanged(boolean onPocket) {
-        mIsDeviceInPocket = onPocket;
-    }
 }
diff --git a/services/core/java/com/android/server/policy/PhoneWindowManager.java b/services/core/java/com/android/server/policy/PhoneWindowManager.java
index ce4708dd0944..0f70069f99bc 100644
--- a/services/core/java/com/android/server/policy/PhoneWindowManager.java
+++ b/services/core/java/com/android/server/policy/PhoneWindowManager.java
@@ -236,8 +236,6 @@ import android.os.UEventObserver;
 import android.os.UserHandle;
 import android.os.VibrationEffect;
 import android.os.Vibrator;
-import android.pocket.IPocketCallback;
-import android.pocket.PocketManager;
 import android.provider.MediaStore;
 import android.provider.Settings;
 import android.service.dreams.DreamManagerInternal;
@@ -318,7 +316,6 @@ import com.android.server.SystemServiceManager;
 import com.android.server.policy.keyguard.KeyguardServiceDelegate;
 import com.android.server.policy.keyguard.KeyguardServiceDelegate.DrawnListener;
 import com.android.server.policy.keyguard.KeyguardStateMonitor.StateCallback;
-import com.android.server.policy.pocket.PocketLock;
 import com.android.server.statusbar.StatusBarManagerInternal;
 import com.android.server.vr.VrManagerInternal;
 import com.android.server.wm.AppTransition;
@@ -378,7 +375,6 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     static final int LONG_PRESS_POWER_SHUT_OFF_NO_CONFIRM = 3;
     static final int LONG_PRESS_POWER_GO_TO_VOICE_ASSIST = 4;
     static final int LONG_PRESS_POWER_TORCH = 5;
-    static final int LONG_PRESS_POWER_HIDE_POCKET_LOCK = 6;
 
     static final int VERY_LONG_PRESS_POWER_NOTHING = 0;
     static final int VERY_LONG_PRESS_POWER_GLOBAL_ACTIONS = 1;
@@ -928,30 +924,6 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     private SensorEventListener mProximityListener;
     private android.os.PowerManager.WakeLock mProximityWakeLock;
 
-    private PocketManager mPocketManager;
-    private PocketLock mPocketLock;
-    private boolean mPocketLockShowing;
-    private boolean mIsDeviceInPocket;
-    private final IPocketCallback mPocketCallback = new IPocketCallback.Stub() {
-
-        @Override
-        public void onStateChanged(boolean isDeviceInPocket, int reason) {
-            boolean wasDeviceInPocket = mIsDeviceInPocket;
-            if (reason == PocketManager.REASON_SENSOR) {
-                mIsDeviceInPocket = isDeviceInPocket;
-            } else {
-                mIsDeviceInPocket = false;
-            }
-            if (wasDeviceInPocket != mIsDeviceInPocket) {
-                handleDevicePocketStateChanged();
-                //if (mKeyHandler != null) {
-                    //mKeyHandler.setIsInPocket(mIsDeviceInPocket);
-                //}
-            }
-        }
-
-    };
-
     private static final int MSG_ENABLE_POINTER_LOCATION = 1;
     private static final int MSG_DISABLE_POINTER_LOCATION = 2;
     private static final int MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK = 3;
@@ -1723,39 +1695,32 @@ public class PhoneWindowManager implements WindowManagerPolicy {
             mPowerKeyWakeLock.acquire();
         }
 
-        // Still allow muting call with power button press.
-        boolean blockInputs = mIsDeviceInPocket && (!interactive || mPocketLockShowing);
-
         // Cancel multi-press detection timeout.
         if (mPowerKeyPressCounter != 0) {
             mHandler.removeMessages(MSG_POWER_DELAYED_PRESS);
         }
 
-        if (!blockInputs) {
-            // Detect user pressing the power button in panic when an application has
-            // taken over the whole screen.
-            boolean panic = mImmersiveModeConfirmation.onPowerKeyDown(interactive,
-                    SystemClock.elapsedRealtime(), isImmersiveMode(mLastSystemUiFlags),
-                    isNavBarEmpty(mLastSystemUiFlags));
-
-            if (panic && !WindowManagerPolicyControl.isImmersiveFiltersActive()) {
-                mHandler.post(mHiddenNavPanic);
-            }
-
-            // Latch power key state to detect screenshot chord.
-            if (interactive && !mScreenshotChordPowerKeyTriggered
-                    && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
-                mScreenshotChordPowerKeyTriggered = true;
-                mScreenshotChordPowerKeyTime = event.getDownTime();
-                interceptScreenshotChord();
-                interceptRingerToggleChord();
-                interceptScreenrecordChord();
-            }
+        // Detect user pressing the power button in panic when an application has
+        // taken over the whole screen.
+        boolean panic = mImmersiveModeConfirmation.onPowerKeyDown(interactive,
+                SystemClock.elapsedRealtime(), isImmersiveMode(mLastSystemUiFlags),
+                isNavBarEmpty(mLastSystemUiFlags));
+        if (panic && !WindowManagerPolicyControl.isImmersiveFiltersActive()) {
+            mHandler.post(mHiddenNavPanic);
         }
 
         // Abort possibly stuck animations.
         mHandler.post(mWindowManagerFuncs::triggerAnimationFailsafe);
 
+        // Latch power key state to detect screenshot chord.
+        if (interactive && !mScreenshotChordPowerKeyTriggered
+                && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
+            mScreenshotChordPowerKeyTriggered = true;
+            mScreenshotChordPowerKeyTime = event.getDownTime();
+            interceptScreenshotChord();
+            interceptRingerToggleChord();
+            interceptScreenrecordChord();
+        }
 
         // Stop ringing or end call if configured to do so when power is pressed.
         TelecomManager telecomManager = getTelecommService();
@@ -1765,7 +1730,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                 // Pressing Power while there's a ringing incoming
                 // call should silence the ringer.
                 telecomManager.silenceRinger();
-            } else if (!blockInputs && (mIncallPowerBehavior
+            } else if ((mIncallPowerBehavior
                     & Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_HANGUP) != 0
                     && telecomManager.isInCall() && interactive) {
                 // Otherwise, if "Power button ends call" is enabled,
@@ -1774,17 +1739,14 @@ public class PhoneWindowManager implements WindowManagerPolicy {
             }
         }
 
-
+        GestureLauncherService gestureService = LocalServices.getService(
+                GestureLauncherService.class);
         boolean gesturedServiceIntercepted = false;
-        if (!blockInputs) {
-            GestureLauncherService gestureService = LocalServices.getService(
-                    GestureLauncherService.class);
-            if (gestureService != null) {
-                gesturedServiceIntercepted = gestureService.interceptPowerKeyDown(event, interactive,
-                        mTmpBoolean);
-                if (mTmpBoolean.value && mRequestedOrGoingToSleep) {
-                    mCameraGestureTriggeredDuringGoingToSleep = true;
-                }
+        if (gestureService != null) {
+            gesturedServiceIntercepted = gestureService.interceptPowerKeyDown(event, interactive,
+                    mTmpBoolean);
+            if (mTmpBoolean.value && mRequestedOrGoingToSleep) {
+                mCameraGestureTriggeredDuringGoingToSleep = true;
             }
         }
 
@@ -2096,12 +2058,6 @@ public class PhoneWindowManager implements WindowManagerPolicy {
             msg.setAsynchronous(true);
             msg.sendToTarget();
             break;
-        case LONG_PRESS_POWER_HIDE_POCKET_LOCK:
-            mPowerKeyHandled = true;
-            performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
-            hidePocketLock(true);
-            mPocketManager.setListeningExternal(false);
-            break;
         }
     }
 
@@ -2168,9 +2124,6 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         if ((mTorchActionMode == 2) && (!isScreenOn() || isDozeMode())) {
             return LONG_PRESS_POWER_TORCH;
         }
-        if (mPocketLockShowing) {
-            return LONG_PRESS_POWER_HIDE_POCKET_LOCK;
-        }
         return mLongPressOnPowerBehavior;
     }
 
@@ -2325,11 +2278,6 @@ public class PhoneWindowManager implements WindowManagerPolicy {
             } else {
                 Slog.d(TAG, "ScreenShot Shortcut Disabled");
 	        }
-            if (!mPocketLockShowing){
-                mScreenshotHelper.takeScreenshot(mScreenshotType,
-                        mStatusBar != null && mStatusBar.isVisibleLw(),
-                        mNavigationBar != null && mNavigationBar.isVisibleLw(), mHandler);
-            }
         }
     }
 
@@ -2655,9 +2603,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         mOPGestures = new OPGesturesListener(context, new OPGesturesListener.Callbacks() {
             @Override
             public void onSwipeThreeFinger() {
-                if (!mPocketLockShowing){
                     mHandler.post(mScreenshotRunnable);
-                }
             }
         });
 
@@ -7332,23 +7278,6 @@ public class PhoneWindowManager implements WindowManagerPolicy {
             return 0;
         }
 
-        // Pre-basic policy based on interactive and pocket lock state.
-        if (mIsDeviceInPocket && (!interactive || mPocketLockShowing)) {
-            if (keyCode != KeyEvent.KEYCODE_POWER &&
-                keyCode != KeyEvent.KEYCODE_VOLUME_UP &&
-                keyCode != KeyEvent.KEYCODE_VOLUME_DOWN &&
-                keyCode != KeyEvent.KEYCODE_MEDIA_PLAY &&
-                keyCode != KeyEvent.KEYCODE_MEDIA_PAUSE &&
-                keyCode != KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE &&
-                keyCode != KeyEvent.KEYCODE_HEADSETHOOK &&
-                keyCode != KeyEvent.KEYCODE_MEDIA_STOP &&
-                keyCode != KeyEvent.KEYCODE_MEDIA_NEXT &&
-                keyCode != KeyEvent.KEYCODE_MEDIA_PREVIOUS &&
-                keyCode != KeyEvent.KEYCODE_VOLUME_MUTE) {
-                return 0;
-            }
-        }
-
         // Basic policy based on interactive state.
         final boolean isVolumeRockerWake = !isScreenOn()
                 && mVolumeRockerWake
@@ -7397,7 +7326,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         if (isValidGlobalKey(keyCode)
                 && mGlobalKeyManager.shouldHandleGlobalKey(keyCode, event)) {
             if (isWakeKey) {
-                wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY");
+                wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey,
+                       "android.policy:KEY", true);
             }
             return result;
         }
@@ -7842,7 +7772,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         }
 
         if (isWakeKey) {
-            wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY");
+            wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY",
+                    event.getKeyCode() == KeyEvent.KEYCODE_WAKEUP /* check prox only on wake key*/);
         }
 
         return result;
@@ -8267,9 +8198,6 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         if (mKeyguardDelegate != null) {
             mKeyguardDelegate.onStartedGoingToSleep(why);
         }
-        if (mPocketManager != null) {
-            mPocketManager.onInteractiveChanged(false);
-        }
     }
 
     // Called on the PowerManager's Notifier thread.
@@ -8318,10 +8246,6 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         if (mKeyguardDelegate != null) {
             mKeyguardDelegate.onStartedWakingUp();
         }
-
-        if (mPocketManager != null) {
-            mPocketManager.onInteractiveChanged(true);
-        }
     }
 
     // Called on the PowerManager's Notifier thread.
@@ -8335,10 +8259,15 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     }
 
     private void wakeUpFromPowerKey(long eventTime) {
-        wakeUp(eventTime, mAllowTheaterModeWakeFromPowerKey, "android.policy:POWER");
+        wakeUp(eventTime, mAllowTheaterModeWakeFromPowerKey, "android.policy:POWER", true);
     }
 
     private boolean wakeUp(long wakeTime, boolean wakeInTheaterMode, String reason) {
+        return wakeUp(wakeTime, wakeInTheaterMode, reason, false);
+    }
+
+    private boolean wakeUp(long wakeTime, boolean wakeInTheaterMode, String reason,
+            final boolean withProximityCheck) {
         final boolean theaterModeEnabled = isTheaterModeEnabled();
         if (!wakeInTheaterMode && theaterModeEnabled) {
             return false;
@@ -8349,7 +8278,11 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                     Settings.Global.THEATER_MODE_ON, 0);
         }
 
-        mPowerManager.wakeUp(wakeTime, reason);
+        if (withProximityCheck) {
+            mPowerManager.wakeUpWithProximityCheck(wakeTime, reason);
+        } else {
+            mPowerManager.wakeUp(wakeTime, reason);
+        }
         return true;
     }
 
@@ -8523,73 +8456,6 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         toggleOrientationListener(true);
     }
 
-    /**
-     * Perform operations if needed on pocket mode state changed.
-     * @see com.android.server.pocket.PocketService
-     * @see PocketLock
-     * @see this.mPocketCallback;
-     * @author Carlo Savignano
-     */
-    private void handleDevicePocketStateChanged() {
-        final boolean interactive = mPowerManager.isInteractive();
-        mImmersiveModeConfirmation.onDevicePocketStateChanged(mIsDeviceInPocket);
-        if (mIsDeviceInPocket) {
-            showPocketLock(interactive);
-        } else {
-            hidePocketLock(interactive);
-        }
-    }
-
-    /**
-     * Check if we can show pocket lock once requested.
-     * @see com.android.server.pocket.PocketService
-     * @see PocketLock
-     * @see this.mPocketCallback;
-     * @author Carlo Savignano
-     */
-    private void showPocketLock(boolean animate) {
-        if (!mSystemReady || !mSystemBooted || !mKeyguardDrawnOnce
-                || mPocketLock == null || mPocketLockShowing) {
-            return;
-        }
-
-        if (mPowerManager.isInteractive() && !isKeyguardShowingAndNotOccluded()){
-            return;
-        }
-
-        if (DEBUG) {
-            Log.d(TAG, "showPocketLock, animate=" + animate);
-        }
-
-        mPocketLock.show(animate);
-        mPocketLockShowing = true;
-
-        mPocketManager.setPocketLockVisible(true);
-    }
-
-    /**
-     * Check if we can hide pocket lock once requested.
-     * @see com.android.server.pocket.PocketService
-     * @see PocketLock
-     * @see this.mPocketCallback;
-     * @author Carlo Savignano
-     */
-    private void hidePocketLock(boolean animate) {
-        if (!mSystemReady || !mSystemBooted || !mKeyguardDrawnOnce
-                || mPocketLock == null || !mPocketLockShowing) {
-            return;
-        }
-
-        if (DEBUG) {
-            Log.d(TAG, "hidePocketLock, animate=" + animate);
-        }
-
-        mPocketLock.hide(animate);
-        mPocketLockShowing = false;
-
-        mPocketManager.setPocketLockVisible(false);
-    }
-
     private void handleHideBootMessage() {
         synchronized (mLock) {
             if (!mKeyguardDrawnOnce) {
@@ -9167,10 +9033,6 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         // So it is better not to bind keyguard here.
         mKeyguardDelegate.onSystemReady();
 
-        mPocketManager = (PocketManager) mContext.getSystemService(Context.POCKET_SERVICE);
-        mPocketManager.addCallback(mPocketCallback);
-        mPocketLock = new PocketLock(mContext);
-
         mVrManagerInternal = LocalServices.getService(VrManagerInternal.class);
         if (mVrManagerInternal != null) {
             mVrManagerInternal.addPersistentVrModeStateListener(mPersistentVrModeListener);
diff --git a/services/core/java/com/android/server/policy/pocket/PocketLock.java b/services/core/java/com/android/server/policy/pocket/PocketLock.java
deleted file mode 100644
index a432d7cce428..000000000000
--- a/services/core/java/com/android/server/policy/pocket/PocketLock.java
+++ /dev/null
@@ -1,190 +0,0 @@
-/*
- * Copyright (C) 2016 The ParanoidAndroid Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.server.policy.pocket;
-
-import android.animation.Animator;
-import android.content.Context;
-import android.graphics.PixelFormat;
-import android.os.Handler;
-import android.view.Gravity;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.WindowManager;
-
-/**
- * This class provides a fullscreen overlays view, displaying itself
- * even on top of lock screen. While this view is displaying touch
- * inputs are not passed to the the views below.
- * @see android.view.WindowManager.LayoutParams.TYPE_SYSTEM_ERROR;
- * @author Carlo Savignano
- */
-public class PocketLock {
-
-    private final Context mContext;
-    private WindowManager mWindowManager;
-    private WindowManager.LayoutParams mLayoutParams;
-    private Handler mHandler;
-    private View mView;
-    private View mHintContainer;
-
-    private boolean mAttached;
-    private boolean mAnimating;
-
-    /**
-     * Creates pocket lock objects, inflate view and set layout parameters.
-     * @param context
-     */
-    public PocketLock(Context context) {
-        mContext = context;
-        mHandler = new Handler();
-        mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
-        mLayoutParams = getLayoutParams();
-        mView = LayoutInflater.from(mContext).inflate(
-                com.android.internal.R.layout.pocket_lock_view_layout, null);
-    }
-
-    public void show(final boolean animate) {
-        final Runnable r = new Runnable() {
-            @Override
-            public void run() {
-                if (mAttached) {
-                    return;
-                }
-
-                if (mAnimating) {
-                    mView.animate().cancel();
-                }
-
-                if (animate) {
-                    mView.setLayerType(View.LAYER_TYPE_HARDWARE, null);
-                    mView.animate().alpha(1.0f).setListener(new Animator.AnimatorListener() {
-                        @Override
-                        public void onAnimationStart(Animator animator) {
-                            mAnimating = true;
-                        }
-
-                        @Override
-                        public void onAnimationEnd(Animator animator) {
-                            mView.setLayerType(View.LAYER_TYPE_NONE, null);
-                            mAnimating = false;
-                        }
-
-                        @Override
-                        public void onAnimationCancel(Animator animator) {
-                        }
-
-                        @Override
-                        public void onAnimationRepeat(Animator animator) {
-                        }
-                    }).withStartAction(new Runnable() {
-                        @Override
-                        public void run() {
-                            mView.setAlpha(0.0f);
-                            addView();
-                        }
-                    }).start();
-                } else {
-                    mView.setAlpha(1.0f);
-                    addView();
-                }
-            }
-        };
-
-        mHandler.post(r);
-    }
-
-    public void hide(final boolean animate) {
-        final Runnable r = new Runnable() {
-            @Override
-            public void run() {
-                if (!mAttached) {
-                    return;
-                }
-
-                if (mAnimating) {
-                    mView.animate().cancel();
-                }
-
-                if (animate) {
-                    mView.setLayerType(View.LAYER_TYPE_HARDWARE, null);
-                    mView.animate().alpha(0.0f).setListener(new Animator.AnimatorListener() {
-                        @Override
-                        public void onAnimationStart(Animator animator) {
-                            mAnimating = true;
-                        }
-
-                        @Override
-                        public void onAnimationEnd(Animator animator) {
-                            mView.setLayerType(View.LAYER_TYPE_NONE, null);
-                            mAnimating = false;
-                            removeView();
-                        }
-
-                        @Override
-                        public void onAnimationCancel(Animator animator) {
-                        }
-
-                        @Override
-                        public void onAnimationRepeat(Animator animator) {
-                        }
-                    }).start();
-                } else {
-                    removeView();
-                    mView.setAlpha(0.0f);
-                }
-            }
-        };
-
-        mHandler.post(r);
-    }
-
-    private void addView() {
-        if (mWindowManager != null && !mAttached) {
-            mWindowManager.addView(mView, mLayoutParams);          
-            mView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_FULLSCREEN
-                | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY
-                | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION);
-            mAttached = true;
-        }
-    }
-
-    private void removeView() {
-        if (mWindowManager != null && mAttached) {          
-            mView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE);
-            mWindowManager.removeView(mView);
-            mAnimating = false;
-            mAttached = false;
-        }
-    }
-
-    private WindowManager.LayoutParams getLayoutParams() {
-        mLayoutParams = new WindowManager.LayoutParams();
-        mLayoutParams.format = PixelFormat.TRANSLUCENT;
-        mLayoutParams.height = WindowManager.LayoutParams.MATCH_PARENT;
-        mLayoutParams.width = WindowManager.LayoutParams.MATCH_PARENT;
-        mLayoutParams.gravity = Gravity.CENTER;
-        mLayoutParams.type = WindowManager.LayoutParams.TYPE_SYSTEM_ERROR;
-        mLayoutParams.layoutInDisplayCutoutMode =
-                WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES;
-        mLayoutParams.flags = WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH
-                | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED
-                | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED
-                | WindowManager.LayoutParams.FLAG_FULLSCREEN
-                | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN;
-        return mLayoutParams;
-    }
-
-}
diff --git a/services/core/java/com/android/server/power/PowerManagerService.java b/services/core/java/com/android/server/power/PowerManagerService.java
index 5ced6692194d..f9e8e1ca8a99 100755
--- a/services/core/java/com/android/server/power/PowerManagerService.java
+++ b/services/core/java/com/android/server/power/PowerManagerService.java
@@ -34,6 +34,9 @@ import android.content.IntentFilter;
 import android.content.pm.PackageManager;
 import android.content.res.Resources;
 import android.database.ContentObserver;
+import android.hardware.Sensor;
+import android.hardware.SensorEvent;
+import android.hardware.SensorEventListener;
 import android.hardware.SensorManager;
 import android.hardware.SystemSensorManager;
 import android.hardware.display.DisplayManagerInternal;
@@ -71,6 +74,7 @@ import android.provider.Settings.SettingNotFoundException;
 import android.service.dreams.DreamManagerInternal;
 import android.service.vr.IVrManager;
 import android.service.vr.IVrStateCallbacks;
+import android.telephony.TelephonyManager;
 import android.util.KeyValueListParser;
 import android.util.PrintWriterPrinter;
 import android.util.Slog;
@@ -137,6 +141,7 @@ public final class PowerManagerService extends SystemService
     private static final int MSG_SCREEN_BRIGHTNESS_BOOST_TIMEOUT = 3;
     // Message: Polling to look for long held wake locks.
     private static final int MSG_CHECK_FOR_LONG_WAKELOCKS = 4;
+    private static final int MSG_WAKE_UP = 5;
 
     // Dirty bit: mWakeLocks changed
     protected static final int DIRTY_WAKE_LOCKS = 1 << 0;
@@ -238,6 +243,7 @@ public final class PowerManagerService extends SystemService
     private static final String BATTERY_CHARGER_PATH =
             "/sys/class/power_supply/battery/battery_charging_enabled";
     private static final String CHARGER_PATH = "/sys/class/power_supply/battery/charging_enabled";
+    private static final float PROXIMITY_NEAR_THRESHOLD = 5.0f;
 
     private final Context mContext;
     private final ServiceThread mHandlerThread;
@@ -709,7 +715,17 @@ public final class PowerManagerService extends SystemService
     private static native void nativeSendPowerHint(int hintId, int data);
     private static native void nativeSetFeature(int featureId, int data);
 
+    // Whether proximity check on wake is enabled by default
+    private boolean mProximityWakeEnabledByDefaultConfig;
+
     private LcdPowerSaveInternal mLcdPowerSaveInternal;
+    private SensorManager mSensorManager;
+    private Sensor mProximitySensor;
+    private boolean mProximityWakeEnabled;
+    private int mProximityTimeOut;
+    private boolean mProximityWakeSupported;
+    private android.os.PowerManager.WakeLock mProximityWakeLock;
+    private SensorEventListener mProximityListener;
 
     public PowerManagerService(Context context) {
         super(context);
@@ -943,6 +959,10 @@ public final class PowerManagerService extends SystemService
                 // Shouldn't happen since in-process.
             }
 
+            // Initialize proximity sensor
+            mSensorManager = mContext.getSystemService(SensorManager.class);
+            mProximitySensor = mSensorManager.getDefaultSensor(Sensor.TYPE_PROXIMITY);
+
             // Go.
             readConfigurationLocked();
             updateSettingsLocked();
@@ -1014,6 +1034,9 @@ public final class PowerManagerService extends SystemService
         resolver.registerContentObserver(Settings.System.getUriFor(
                 Settings.System.WAKELOCK_BLOCKING_LIST),
                 false, mSettingsObserver, UserHandle.USER_ALL);
+        resolver.registerContentObserver(Settings.System.getUriFor(
+                Settings.System.PROXIMITY_ON_WAKE),
+                false, mSettingsObserver, UserHandle.USER_ALL);
         resolver.registerContentObserver(Settings.System.getUriFor(
                 Settings.System.DOZE_ON_CHARGE_NOW),
                 false, mSettingsObserver, UserHandle.USER_ALL);
@@ -1097,6 +1120,16 @@ public final class PowerManagerService extends SystemService
                 com.android.internal.R.bool.config_supportDoubleTapWake);
         mSmartChargingLevelDefaultConfig = resources.getInteger(
                 com.android.internal.R.integer.config_smartChargingBatteryLevel);
+        mProximityTimeOut = resources.getInteger(
+                com.android.internal.R.integer.config_proximityCheckTimeout);
+        mProximityWakeSupported = resources.getBoolean(
+                com.android.internal.R.bool.config_proximityCheckOnWake);
+        mProximityWakeEnabledByDefaultConfig = resources.getBoolean(
+                com.android.internal.R.bool.config_proximityCheckOnWakeEnabledByDefault);
+        if (mProximityWakeSupported) {
+            mProximityWakeLock = mContext.getSystemService(PowerManager.class)
+                    .newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "ProximityWakeLock");
+        }
     }
 
     private void updateSettingsLocked() {
@@ -1179,6 +1212,11 @@ public final class PowerManagerService extends SystemService
                 Settings.Secure.HARDWARE_KEYS_DISABLE, 0,
                 UserHandle.USER_CURRENT) != 0;
 
+        mProximityWakeEnabled = (Settings.System.getIntForUser(resolver,
+                Settings.System.PROXIMITY_ON_WAKE,
+                mProximityWakeEnabledByDefaultConfig ? 1 : 0,
+                UserHandle.USER_CURRENT) != 0);
+
         mDirty |= DIRTY_SETTINGS;
     }
 
@@ -4243,6 +4281,10 @@ public final class PowerManagerService extends SystemService
                 case MSG_CHECK_FOR_LONG_WAKELOCKS:
                     checkForLongWakeLocks();
                     break;
+                case MSG_WAKE_UP:
+                    cleanupProximity();
+                    ((Runnable) msg.obj).run();
+                    break;
             }
         }
     }
@@ -4685,6 +4727,19 @@ public final class PowerManagerService extends SystemService
 
         @Override // Binder call
         public void wakeUp(long eventTime, String reason, String opPackageName) {
+            wakeUp(eventTime, reason, opPackageName, false);
+        }
+
+        @Override // Binder call
+        public void wakeUpWithProximityCheck(long eventTime, String reason, String opPackageName) {
+            wakeUp(eventTime, reason, opPackageName, true);
+        }
+
+        /**
+         * @hide
+         */
+        private void wakeUp(long eventTime, String reason, String opPackageName,
+                final boolean checkProximity) {
             if (eventTime > SystemClock.uptimeMillis()) {
                 throw new IllegalArgumentException("event time must not be in the future");
             }
@@ -4693,11 +4748,21 @@ public final class PowerManagerService extends SystemService
                     android.Manifest.permission.DEVICE_POWER, null);
 
             final int uid = Binder.getCallingUid();
-            final long ident = Binder.clearCallingIdentity();
-            try {
-                wakeUpInternal(eventTime, reason, uid, opPackageName, uid);
-            } finally {
-                Binder.restoreCallingIdentity(ident);
+            final Runnable r = new Runnable() {
+                @Override
+                public void run() {
+                    final long ident = Binder.clearCallingIdentity();
+                    try {
+                        wakeUpInternal(eventTime, reason, uid, opPackageName, uid);
+                    } finally {
+                        Binder.restoreCallingIdentity(ident);
+                    }
+                }
+            };
+            if (checkProximity) {
+                runWithProximityCheck(r);
+            } else {
+                r.run();
             }
         }
 
@@ -5201,4 +5266,76 @@ public final class PowerManagerService extends SystemService
             powerHintInternal(hintId, data);
         }
     }
+
+    private void cleanupProximity() {
+        synchronized (mProximityWakeLock) {
+            cleanupProximityLocked();
+        }
+    }
+
+    private void cleanupProximityLocked() {
+        if (mProximityWakeLock.isHeld()) {
+            mProximityWakeLock.release();
+        }
+        if (mProximityListener != null) {
+            mSensorManager.unregisterListener(mProximityListener);
+            mProximityListener = null;
+        }
+    }
+
+    private void runWithProximityCheck(final Runnable r) {
+        if (mHandler.hasMessages(MSG_WAKE_UP)) {
+            // There is already a message queued;
+            return;
+        }
+
+        final TelephonyManager tm =
+                (TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE);
+        final boolean hasIncomingCall = tm.getCallState() == TelephonyManager.CALL_STATE_RINGING;
+
+        if (mProximityWakeSupported && mProximityWakeEnabled
+                && mProximitySensor != null && !hasIncomingCall) {
+            final Message msg = mHandler.obtainMessage(MSG_WAKE_UP);
+            msg.obj = r;
+            mHandler.sendMessageDelayed(msg, mProximityTimeOut);
+            runPostProximityCheck(r);
+        } else {
+            r.run();
+        }
+    }
+
+    private void runPostProximityCheck(final Runnable r) {
+        if (mSensorManager == null) {
+            r.run();
+            return;
+        }
+        synchronized (mProximityWakeLock) {
+            mProximityWakeLock.acquire();
+            mProximityListener = new SensorEventListener() {
+                @Override
+                public void onSensorChanged(SensorEvent event) {
+                    cleanupProximityLocked();
+                    if (!mHandler.hasMessages(MSG_WAKE_UP)) {
+                        Slog.w(TAG, "Proximity sensor took too long, wake event already triggered!");
+                        return;
+                    }
+                    mHandler.removeMessages(MSG_WAKE_UP);
+                    final float distance = event.values[0];
+                    if (distance >= PROXIMITY_NEAR_THRESHOLD ||
+                            distance >= mProximitySensor.getMaximumRange()) {
+                        r.run();
+                    } else {
+                        Slog.w(TAG, "Not waking up. Proximity sensor is blocked.");
+                    }
+                }
+
+                @Override
+                public void onAccuracyChanged(Sensor sensor, int accuracy) {
+                    // Do nothing
+                }
+            };
+            mSensorManager.registerListener(mProximityListener,
+                   mProximitySensor, SensorManager.SENSOR_DELAY_FASTEST);
+        }
+    }
 }
diff --git a/services/java/com/android/server/SystemServer.java b/services/java/com/android/server/SystemServer.java
index b01840fa9781..77ea95a0051f 100644
--- a/services/java/com/android/server/SystemServer.java
+++ b/services/java/com/android/server/SystemServer.java
@@ -101,8 +101,6 @@ import com.android.server.oemlock.OemLockService;
 import com.android.server.om.OverlayManagerService;
 import com.android.server.os.DeviceIdentifiersPolicyService;
 import com.android.server.os.SchedulingPolicyService;
-import com.android.server.pocket.PocketService;
-import com.android.server.pocket.PocketBridgeService;
 import com.android.server.pm.BackgroundDexOptService;
 import com.android.server.pm.CrossProfileAppsService;
 import com.android.server.pm.Installer;
@@ -1642,9 +1640,6 @@ public final class SystemServer {
 
             traceBeginAndSlog("StartCrossProfileAppsService");
             mSystemServiceManager.startService(CrossProfileAppsService.class);
-
-            traceBeginAndSlog("StartPocketService");
-            mSystemServiceManager.startService(PocketService.class);
             traceEnd();
 
             traceBeginAndSlog("Starting ScreenStabilization Service");
@@ -1668,13 +1663,6 @@ public final class SystemServer {
                 mSystemServiceManager.startService(LiveDisplayService.class);
                 traceEnd();
             }
-
-            if (!context.getResources().getString(
-                    com.android.internal.R.string.config_pocketBridgeSysfsInpocket).isEmpty()) {
-                traceBeginAndSlog("StartPocketBridgeService");
-                mSystemServiceManager.startService(PocketBridgeService.class);
-                traceEnd();
-            }
         }
 
         if (!isWatch) {
-- 
2.20.1

