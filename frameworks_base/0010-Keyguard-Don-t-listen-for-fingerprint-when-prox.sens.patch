From a34afc035404d2b329e47997a69c562a20ee5733 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?eray=20or=C3=A7unus?= <erayorcunus@gmail.com>
Date: Fri, 4 Aug 2017 00:23:20 +0300
Subject: [PATCH 10/12] Keyguard: Don't listen for fingerprint when prox.sensor
 is covered

* It's being added as an extra feature over
  'Prevent accidental wakes' toggle.
* Can be toggled on per-device basis. Some devices have
  kernel approaches and they can prefer that way, but some don't.
  Like zl1 and capricorn.
* Device must have NON-WAKEUP proximity sensor.
* Obviously only works while screen is off.

Change-Id: Iba6a225a3e1a3192d20f16b6cdd45b0e5504407a
Signed-off-by: Kazakov Stepan <ksrt12group@gmail.com>
---
 core/res/res/values/config.xml                |  4 ++
 core/res/res/values/symbols.xml               |  3 +
 .../keyguard/KeyguardUpdateMonitor.java       | 70 ++++++++++++++++++-
 3 files changed, 75 insertions(+), 2 deletions(-)

diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index 44fa1736bb45..6fbfc402c148 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -3569,6 +3569,10 @@
 
     <!-- Whether or not swipe up gesture's opt-in setting is available on this device -->
     <bool name="config_swipe_up_gesture_setting_available">true</bool>
+    
+    <!-- Stop listening to the fingerprint reader when NON-WAKEUP proximity sensor is covered & screen is off.
+         config_proximityCheckOnWake must be true. -->
+    <bool name="config_proximityCheckOnFingerprintWake">false</bool>
 
     <!-- The duration (in milliseconds) for the outgoing sms authorization request to timeout.-->
     <integer name="config_sms_authorization_timeout_ms">0</integer>
diff --git a/core/res/res/values/symbols.xml b/core/res/res/values/symbols.xml
index 102f8f054028..bd052c9b02be 100644
--- a/core/res/res/values/symbols.xml
+++ b/core/res/res/values/symbols.xml
@@ -2948,6 +2948,9 @@
   <java-symbol type="string" name="config_dozeDoubleTapSensorType" />
   <java-symbol type="bool" name="config_dozePulsePickup" />
 
+  <!-- Should proximity check also affect fingerprint reader-->
+  <java-symbol type="bool" name="config_proximityCheckOnFingerprintWake" />
+
   <!-- Used for MimeIconUtils. -->
   <java-symbol type="drawable" name="ic_doc_apk" />
   <java-symbol type="drawable" name="ic_doc_audio" />
diff --git a/packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java b/packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java
index 27e3f294463e..983f0c8e56bb 100644
--- a/packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java
+++ b/packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java
@@ -52,6 +52,10 @@ import android.database.ContentObserver;
 import android.hardware.fingerprint.FingerprintManager;
 import android.hardware.fingerprint.FingerprintManager.AuthenticationCallback;
 import android.hardware.fingerprint.FingerprintManager.AuthenticationResult;
+import android.hardware.Sensor;
+import android.hardware.SensorEvent;
+import android.hardware.SensorEventListener;
+import android.hardware.SensorManager;
 import android.media.AudioManager;
 import android.os.BatteryManager;
 import android.os.CancellationSignal;
@@ -155,7 +159,8 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener,
     private static final int MSG_ASSISTANT_STACK_CHANGED = 335;
     private static final int MSG_FINGERPRINT_AUTHENTICATION_CONTINUE = 336;
     private static final int MSG_DEVICE_POLICY_MANAGER_STATE_CHANGED = 337;
-    private static final int MSG_TELEPHONY_CAPABLE = 338;
+    private static final int MSG_PROXIMITY_CHANGE = 338;
+    private static final int MSG_TELEPHONY_CAPABLE = 339;
 
     // Additional messages should be 600+
     private static final int MSG_POCKET_STATE_CHANGED = 600;
@@ -216,6 +221,7 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener,
     private boolean mHasLockscreenWallpaper;
     private boolean mAssistantVisible;
     private boolean mKeyguardOccluded;
+    private boolean mProximitySensorCovered;
     @VisibleForTesting
     protected boolean mTelephonyCapable;
     protected boolean mPulsing;
@@ -231,6 +237,7 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener,
     private final ArrayList<WeakReference<KeyguardUpdateMonitorCallback>>
             mCallbacks = Lists.newArrayList();
     private ContentObserver mDeviceProvisionedObserver;
+    private SensorEventListener mSensorEventListener;
 
     private boolean mSwitchingUser;
 
@@ -238,6 +245,8 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener,
     private boolean mScreenOn;
     private SubscriptionManager mSubscriptionManager;
     private List<SubscriptionInfo> mSubscriptionInfo;
+    private SensorManager mSensorManager;
+    private Sensor mSensor;
     private TrustManager mTrustManager;
     private UserManager mUserManager;
     private int mFingerprintRunningState = FINGERPRINT_STATE_STOPPED;
@@ -353,6 +362,8 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener,
                     break;
                 case MSG_FINGERPRINT_AUTHENTICATION_CONTINUE:
                     updateFingerprintListeningState();
+                case MSG_PROXIMITY_CHANGE:
+                    handleProximityChange();
                     break;
                 case MSG_DEVICE_POLICY_MANAGER_STATE_CHANGED:
                     updateLogoutEnabled();
@@ -1138,6 +1149,41 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener,
         return sInstance;
     }
 
+    private void enableProximityListener() {
+        if(Settings.System.getInt(
+                mContext.getContentResolver(),Settings.System.PROXIMITY_ON_WAKE,0) == 0 ||
+                !mContext.getResources().getBoolean(
+                com.android.internal.R.bool.config_proximityCheckOnFingerprintWake) ||
+                !mContext.getResources().getBoolean(
+                com.android.internal.R.bool.config_proximityCheckOnWake) ||
+                mSensor == null || mSensorEventListener != null)
+            return;
+
+        mSensorEventListener = new SensorEventListener() {
+
+            @Override
+            public void onSensorChanged(SensorEvent event) {
+                mProximitySensorCovered = event.values[0] < mSensor.getMaximumRange();
+                mHandler.sendEmptyMessage(MSG_PROXIMITY_CHANGE);
+            }
+
+            @Override
+            public void onAccuracyChanged(Sensor sensor, int accuracy) {
+                /* Do nothing */
+            }
+        };
+
+        mSensorManager.registerListener(mSensorEventListener, mSensor,
+                SensorManager.SENSOR_DELAY_NORMAL);
+    }
+
+    private void disableProximityListener() {
+        if(mSensorEventListener != null){
+            mSensorManager.unregisterListener(mSensorEventListener, mSensor);
+            mSensorEventListener = null;
+        }
+    }
+
     protected void handleStartedWakingUp() {
         Trace.beginSection("KeyguardUpdateMonitor#handleStartedWakingUp");
         updateFingerprintListeningState();
@@ -1177,6 +1223,7 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener,
     }
 
     private void handleScreenTurnedOn() {
+        disableProximityListener();
         final int count = mCallbacks.size();
         for (int i = 0; i < count; i++) {
             KeyguardUpdateMonitorCallback cb = mCallbacks.get(i).get();
@@ -1187,6 +1234,7 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener,
     }
 
     private void handleScreenTurnedOff() {
+        enableProximityListener();
         mHardwareUnavailableRetryCount = 0;
         final int count = mCallbacks.size();
         for (int i = 0; i < count; i++) {
@@ -1232,6 +1280,8 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener,
     protected KeyguardUpdateMonitor(Context context) {
         mContext = context;
         mSubscriptionManager = SubscriptionManager.from(context);
+        mSensorManager = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE);
+        mSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_PROXIMITY,false);
         mDeviceProvisioned = isDeviceProvisionedInSettingsDb();
         mStrongAuthTracker = new StrongAuthTracker(context);
 
@@ -1315,6 +1365,13 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener,
         updateAirplaneModeState();
     }
 
+    private boolean proximitySensorAllowsUsingFingerprint() {
+        if(mSensorEventListener != null && mProximitySensorCovered)
+            return false;
+
+        return true;
+    }
+
     private void updateAirplaneModeState() {
         // ACTION_AIRPLANE_MODE_CHANGED do not broadcast if device set AirplaneMode ON and boot
         if (!WirelessUtils.isAirplaneModeOn(mContext)
@@ -1347,12 +1404,13 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener,
                 && !mUserHasTrust.get(getCurrentUser(), false);
     }
 
+
     private boolean shouldListenForFingerprint() {
         return (mKeyguardIsVisible || !mDeviceInteractive ||
                 (mBouncer && !mKeyguardGoingAway) || mGoingToSleep ||
                 shouldListenForFingerprintAssistant() || (mKeyguardOccluded && mIsDreaming))
                 && !mSwitchingUser && !isFingerprintDisabled(getCurrentUser())
-                && !mKeyguardGoingAway;
+                && !mKeyguardGoingAway && proximitySensorAllowsUsingFingerprint();
     }
 
     private void startListeningForFingerprint() {
@@ -1735,6 +1793,14 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener,
         mNeedsSlowUnlockTransition = resolveNeedsSlowUnlockTransition();
     }
 
+    /**
+     * Handle {@link #MSG_PROXIMITY_CHANGE}
+     */
+    private void handleProximityChange() {
+        if (DEBUG) Log.d(TAG, "handleProximityChange");
+        updateFingerprintListeningState();
+    }
+
     private boolean resolveNeedsSlowUnlockTransition() {
         if (mUserManager.isUserUnlocked(getCurrentUser())) {
             return false;
-- 
2.20.1

